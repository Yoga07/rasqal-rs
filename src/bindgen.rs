/* automatically generated by rust-bindgen */

use libc;

pub const RASQAL_VERSION: u32 = 933;
pub const RASQAL_VERSION_STRING: *const libc::c_char = (b"0.9.33\0" as *const libc::c_uchar) as *const libc::c_char;
pub const RASQAL_VERSION_MAJOR: u32 = 0;
pub const RASQAL_VERSION_MINOR: u32 = 9;
pub const RASQAL_VERSION_RELEASE: u32 = 33;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 0;
pub const __DARWIN_ONLY_VERS_1050: u32 = 0;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_64_BIT_INO_T: *const libc::c_char = (b"$INODE64\0" as *const libc::c_uchar) as *const libc::c_char;
pub const __DARWIN_SUF_1050: *const libc::c_char = (b"$1050\0" as *const libc::c_uchar) as *const libc::c_char;
pub const __DARWIN_SUF_EXTSN: *const libc::c_char = (b"$DARWIN_EXTSN\0" as *const libc::c_uchar) as *const libc::c_char;
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __API_TO_BE_DEPRECATED: u32 = 100000;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __MAC_10_13: u32 = 101300;
pub const __MAC_10_13_1: u32 = 101301;
pub const __MAC_10_13_2: u32 = 101302;
pub const __MAC_10_13_4: u32 = 101304;
pub const __MAC_10_14: u32 = 101400;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __IPHONE_11_0: u32 = 110000;
pub const __IPHONE_11_1: u32 = 110100;
pub const __IPHONE_11_2: u32 = 110200;
pub const __IPHONE_11_3: u32 = 110300;
pub const __IPHONE_11_4: u32 = 110400;
pub const __IPHONE_12_0: u32 = 120000;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __TVOS_11_0: u32 = 110000;
pub const __TVOS_11_1: u32 = 110100;
pub const __TVOS_11_2: u32 = 110200;
pub const __TVOS_11_3: u32 = 110300;
pub const __TVOS_11_4: u32 = 110400;
pub const __TVOS_12_0: u32 = 120000;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __WATCHOS_4_0: u32 = 40000;
pub const __WATCHOS_4_1: u32 = 40100;
pub const __WATCHOS_4_2: u32 = 40200;
pub const __WATCHOS_4_3: u32 = 40300;
pub const __WATCHOS_5_0: u32 = 50000;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 101400;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 2;
pub const RENAME_SECLUDE: u32 = 1;
pub const RENAME_SWAP: u32 = 2;
pub const RENAME_EXCL: u32 = 4;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SMOD: u32 = 8192;
pub const __SALC: u32 = 16384;
pub const __SIGN: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 1024;
pub const EOF: i32 = -1;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const P_tmpdir: *const libc::c_char = (b"/var/tmp/\0" as *const libc::c_uchar) as *const libc::c_char;
pub const L_tmpnam: u32 = 1024;
pub const TMP_MAX: u32 = 308915776;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const L_ctermid: u32 = 1024;
pub const __CTERMID_DEFINED: u32 = 1;
pub const _USE_FORTIFY_LEVEL: u32 = 2;
pub const __GNUC_VA_LIST: u32 = 1;
pub const RAPTOR_V2_AVAILABLE: u32 = 1;
pub const RAPTOR_VERSION: u32 = 20015;
pub const RAPTOR_VERSION_STRING: *const libc::c_char = (b"2.0.15\0" as *const libc::c_uchar) as *const libc::c_char;
pub const RAPTOR_VERSION_MAJOR: u32 = 2;
pub const RAPTOR_VERSION_MINOR: u32 = 0;
pub const RAPTOR_VERSION_RELEASE: u32 = 15;
pub const __DARWIN_FD_SETSIZE: u32 = 1024;
pub const __DARWIN_NBBY: u32 = 8;
pub const ITIMER_REAL: u32 = 0;
pub const ITIMER_VIRTUAL: u32 = 1;
pub const ITIMER_PROF: u32 = 2;
pub const FD_SETSIZE: u32 = 1024;
pub const DST_NONE: u32 = 0;
pub const DST_USA: u32 = 1;
pub const DST_AUST: u32 = 2;
pub const DST_WET: u32 = 3;
pub const DST_MET: u32 = 4;
pub const DST_EET: u32 = 5;
pub const DST_CAN: u32 = 6;
pub const CLOCKS_PER_SEC: u32 = 1000000;
pub const RASQAL_RAPTOR_VERSION: u32 = 20015;
pub const RASQAL_WORLD_DECLARED: u32 = 1;
pub const RASQAL_QUERY_RESULTS_FORMATTER_DECLARED: u32 = 1;
pub const RASQAL_LITERAL_UDT_DEFINED: u32 = 1;
pub const RASQAL_XSD_DATETIME_NO_TZ: u32 = 9999;
pub const RASQAL_TRIPLES_SOURCE_MIN_VERSION: u32 = 1;
pub const RASQAL_TRIPLES_SOURCE_MAX_VERSION: u32 = 2;
pub const RASQAL_TRIPLES_SOURCE_FACTORY_MIN_VERSION: u32 = 1;
pub const RASQAL_TRIPLES_SOURCE_FACTORY_MAX_VERSION: u32 = 3;
pub type __int8_t = libc::c_schar;
pub type __uint8_t = libc::c_uchar;
pub type __int16_t = libc::c_short;
pub type __uint16_t = libc::c_ushort;
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __int64_t = libc::c_longlong;
pub type __uint64_t = libc::c_ulonglong;
pub type __darwin_intptr_t = libc::c_long;
pub type __darwin_natural_t = libc::c_uint;
pub type __darwin_ct_rune_t = libc::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [libc::c_char; 128usize],
    pub _mbstateL: libc::c_longlong,
    _bindgen_union_align: [u64; 16usize],
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__mbstate8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>()))._mbstateL as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = libc::c_long;
pub type __darwin_size_t = libc::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = libc::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = libc::c_int;
pub type __darwin_clock_t = libc::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = libc::c_long;
pub type __darwin_time_t = libc::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = libc::c_uint;
pub type __darwin_fsfilcnt_t = libc::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [libc::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [libc::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut libc::c_void)>,
    pub __arg: *mut libc::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__routine as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__arg as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__next as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__next)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: libc::c_long,
    pub __opaque: [libc::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_attr_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_attr_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: libc::c_long,
    pub __opaque: [libc::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_cond_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_cond_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: libc::c_long,
    pub __opaque: [libc::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_condattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_condattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: libc::c_long,
    pub __opaque: [libc::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: libc::c_long,
    pub __opaque: [libc::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutexattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutexattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: libc::c_long,
    pub __opaque: [libc::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_once_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_once_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: libc::c_long,
    pub __opaque: [libc::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: libc::c_long,
    pub __opaque: [libc::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlockattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlockattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: libc::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [libc::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_t>())).__cleanup_stack as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__opaque as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = libc::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type __darwin_nl_item = libc::c_int;
pub type __darwin_wctrans_t = libc::c_int;
pub type __darwin_wctype_t = __uint32_t;
pub type u_int8_t = libc::c_uchar;
pub type u_int16_t = libc::c_ushort;
pub type u_int32_t = libc::c_uint;
pub type u_int64_t = libc::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type va_list = __darwin_va_list;
extern "C" {
    pub fn renameat(
        arg1: libc::c_int,
        arg2: *const libc::c_char,
        arg3: libc::c_int,
        arg4: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn renamex_np(
        arg1: *const libc::c_char,
        arg2: *const libc::c_char,
        arg3: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn renameatx_np(
        arg1: libc::c_int,
        arg2: *const libc::c_char,
        arg3: libc::c_int,
        arg4: *const libc::c_char,
        arg5: libc::c_uint,
    ) -> libc::c_int;
}
pub type fpos_t = __darwin_off_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut libc::c_uchar,
    pub _size: libc::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    assert_eq!(
        ::std::mem::size_of::<__sbuf>(),
        16usize,
        concat!("Size of: ", stringify!(__sbuf))
    );
    assert_eq!(
        ::std::mem::align_of::<__sbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(__sbuf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sbuf>()))._base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sbuf>()))._size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILEX {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut libc::c_uchar,
    pub _r: libc::c_int,
    pub _w: libc::c_int,
    pub _flags: libc::c_short,
    pub _file: libc::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: libc::c_int,
    pub _cookie: *mut libc::c_void,
    pub _close: ::std::option::Option<unsafe extern "C" fn(arg1: *mut libc::c_void) -> libc::c_int>,
    pub _read: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut libc::c_void, arg2: *mut libc::c_char, arg3: libc::c_int)
            -> libc::c_int,
    >,
    pub _seek: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut libc::c_void, arg2: fpos_t, arg3: libc::c_int) -> fpos_t,
    >,
    pub _write: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut libc::c_void, arg2: *const libc::c_char, arg3: libc::c_int)
            -> libc::c_int,
    >,
    pub _ub: __sbuf,
    pub _extra: *mut __sFILEX,
    pub _ur: libc::c_int,
    pub _ubuf: [libc::c_uchar; 3usize],
    pub _nbuf: [libc::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: libc::c_int,
    pub _offset: fpos_t,
}
#[test]
fn bindgen_test_layout___sFILE() {
    assert_eq!(
        ::std::mem::size_of::<__sFILE>(),
        152usize,
        concat!("Size of: ", stringify!(__sFILE))
    );
    assert_eq!(
        ::std::mem::align_of::<__sFILE>(),
        8usize,
        concat!("Alignment of ", stringify!(__sFILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_p)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._r as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._w as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._file as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._bf as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_bf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._lbfsize as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lbfsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._cookie as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_cookie)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._close as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_close)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._read as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._seek as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_seek)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._write as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_write)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._ub as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ub)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._extra as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_extra)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._ur as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ur)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._ubuf as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ubuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._nbuf as *const _ as usize },
        119usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_nbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._lb as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._blksize as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_blksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_offset)
        )
    );
}
pub type FILE = __sFILE;
extern "C" {
    pub static mut __stdinp: *mut FILE;
}
extern "C" {
    pub static mut __stdoutp: *mut FILE;
}
extern "C" {
    pub static mut __stderrp: *mut FILE;
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> libc::c_int;
}
extern "C" {
    pub fn fgets(arg1: *mut libc::c_char, arg2: libc::c_int, arg3: *mut FILE) -> *mut libc::c_char;
}
extern "C" {
    pub fn fopen(__filename: *const libc::c_char, __mode: *const libc::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fprintf(arg1: *mut FILE, arg2: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn fputc(arg1: libc::c_int, arg2: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const libc::c_char, arg2: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut libc::c_void,
        __size: usize,
        __nitems: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn freopen(
        arg1: *const libc::c_char,
        arg2: *const libc::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fscanf(arg1: *mut FILE, arg2: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn fseek(arg1: *mut FILE, arg2: libc::c_long, arg3: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> libc::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> libc::c_long;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const libc::c_void,
        __size: usize,
        __nitems: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn getchar() -> libc::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn perror(arg1: *const libc::c_char);
}
extern "C" {
    pub fn printf(arg1: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn putc(arg1: libc::c_int, arg2: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn putchar(arg1: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn puts(arg1: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn remove(arg1: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn rename(__old: *const libc::c_char, __new: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn scanf(arg1: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut libc::c_char);
}
extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut libc::c_char,
        arg3: libc::c_int,
        arg4: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn sprintf(arg1: *mut libc::c_char, arg2: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn sscanf(arg1: *const libc::c_char, arg2: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn ungetc(arg1: libc::c_int, arg2: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const libc::c_char,
        arg3: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub fn vprintf(arg1: *const libc::c_char, arg2: *mut __va_list_tag) -> libc::c_int;
}
extern "C" {
    pub fn vsprintf(
        arg1: *mut libc::c_char,
        arg2: *const libc::c_char,
        arg3: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ctermid(arg1: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn fdopen(arg1: libc::c_int, arg2: *const libc::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn popen(arg1: *const libc::c_char, arg2: *const libc::c_char) -> *mut FILE;
}
extern "C" {
    pub fn __srget(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn __svfscanf(
        arg1: *mut FILE,
        arg2: *const libc::c_char,
        arg3: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub fn __swbuf(arg1: libc::c_int, arg2: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> libc::c_int;
}
extern "C" {
    pub fn putc_unlocked(arg1: libc::c_int, arg2: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn putw(arg1: libc::c_int, arg2: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn tempnam(__dir: *const libc::c_char, __prefix: *const libc::c_char) -> *mut libc::c_char;
}
pub type off_t = __darwin_off_t;
extern "C" {
    pub fn fseeko(__stream: *mut FILE, __offset: off_t, __whence: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> off_t;
}
extern "C" {
    pub fn snprintf(
        __str: *mut libc::c_char,
        __size: usize,
        __format: *const libc::c_char,
        ...
    ) -> libc::c_int;
}
extern "C" {
    pub fn vfscanf(
        __stream: *mut FILE,
        __format: *const libc::c_char,
        arg1: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub fn vscanf(__format: *const libc::c_char, arg1: *mut __va_list_tag) -> libc::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __str: *mut libc::c_char,
        __size: usize,
        __format: *const libc::c_char,
        arg1: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub fn vsscanf(
        __str: *const libc::c_char,
        __format: *const libc::c_char,
        arg1: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub fn dprintf(arg1: libc::c_int, arg2: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn vdprintf(
        arg1: libc::c_int,
        arg2: *const libc::c_char,
        arg3: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub fn getdelim(
        __linep: *mut *mut libc::c_char,
        __linecapp: *mut usize,
        __delimiter: libc::c_int,
        __stream: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn getline(
        __linep: *mut *mut libc::c_char,
        __linecapp: *mut usize,
        __stream: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn fmemopen(
        __buf: *mut libc::c_void,
        __size: usize,
        __mode: *const libc::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(__bufp: *mut *mut libc::c_char, __sizep: *mut usize) -> *mut FILE;
}
extern "C" {
    pub static sys_nerr: libc::c_int;
}
extern "C" {
    pub static mut sys_errlist: [*const libc::c_char; 0usize];
}
extern "C" {
    pub fn asprintf(arg1: *mut *mut libc::c_char, arg2: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn ctermid_r(arg1: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn fgetln(arg1: *mut FILE, arg2: *mut usize) -> *mut libc::c_char;
}
extern "C" {
    pub fn fmtcheck(arg1: *const libc::c_char, arg2: *const libc::c_char) -> *const libc::c_char;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn setbuffer(arg1: *mut FILE, arg2: *mut libc::c_char, arg3: libc::c_int);
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn vasprintf(
        arg1: *mut *mut libc::c_char,
        arg2: *const libc::c_char,
        arg3: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub fn zopen(
        arg1: *const libc::c_char,
        arg2: *const libc::c_char,
        arg3: libc::c_int,
    ) -> *mut FILE;
}
extern "C" {
    pub fn funopen(
        arg1: *const libc::c_void,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut libc::c_void,
                arg2: *mut libc::c_char,
                arg3: libc::c_int,
            ) -> libc::c_int,
        >,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut libc::c_void,
                arg2: *const libc::c_char,
                arg3: libc::c_int,
            ) -> libc::c_int,
        >,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut libc::c_void, arg2: fpos_t, arg3: libc::c_int)
                -> fpos_t,
        >,
        arg5: ::std::option::Option<unsafe extern "C" fn(arg1: *mut libc::c_void) -> libc::c_int>,
    ) -> *mut FILE;
}
extern "C" {
    pub fn __sprintf_chk(
        arg1: *mut libc::c_char,
        arg2: libc::c_int,
        arg3: usize,
        arg4: *const libc::c_char,
        ...
    ) -> libc::c_int;
}
extern "C" {
    pub fn __snprintf_chk(
        arg1: *mut libc::c_char,
        arg2: usize,
        arg3: libc::c_int,
        arg4: usize,
        arg5: *const libc::c_char,
        ...
    ) -> libc::c_int;
}
extern "C" {
    pub fn __vsprintf_chk(
        arg1: *mut libc::c_char,
        arg2: libc::c_int,
        arg3: usize,
        arg4: *const libc::c_char,
        arg5: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub fn __vsnprintf_chk(
        arg1: *mut libc::c_char,
        arg2: usize,
        arg3: libc::c_int,
        arg4: usize,
        arg5: *const libc::c_char,
        arg6: *mut __va_list_tag,
    ) -> libc::c_int;
}
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raptor_uri_s {
    _unused: [u8; 0],
}
/// raptor_uri:
///
/// Raptor URI Class.
pub type raptor_uri = raptor_uri_s;
extern "C" {
    pub static raptor_short_copyright_string: *const libc::c_char;
}
extern "C" {
    pub static raptor_copyright_string: *const libc::c_char;
}
extern "C" {
    pub static raptor_version_string: *const libc::c_char;
}
extern "C" {
    pub static raptor_version_major: libc::c_uint;
}
extern "C" {
    pub static raptor_version_minor: libc::c_uint;
}
extern "C" {
    pub static raptor_version_release: libc::c_uint;
}
extern "C" {
    pub static raptor_version_decimal: libc::c_uint;
}
extern "C" {
    pub static raptor_license_string: *const libc::c_char;
}
extern "C" {
    pub static raptor_home_url_string: *const libc::c_char;
}
extern "C" {
    pub static raptor_xml_namespace_uri: *const libc::c_uchar;
}
extern "C" {
    pub static raptor_rdf_namespace_uri: *const libc::c_uchar;
}
extern "C" {
    pub static raptor_rdf_namespace_uri_len: libc::c_uint;
}
extern "C" {
    pub static raptor_rdf_schema_namespace_uri: *const libc::c_uchar;
}
extern "C" {
    pub static raptor_xmlschema_datatypes_namespace_uri: *const libc::c_uchar;
}
extern "C" {
    pub static raptor_owl_namespace_uri: *const libc::c_uchar;
}
extern "C" {
    pub static raptor_xml_literal_datatype_uri_string: *const libc::c_uchar;
}
extern "C" {
    pub static raptor_xml_literal_datatype_uri_string_len: libc::c_uint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raptor_world_s {
    _unused: [u8; 0],
}
/// raptor_world:
///
/// Raptor world class.
pub type raptor_world = raptor_world_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raptor_parser_s {
    _unused: [u8; 0],
}
/// raptor_parser:
///
/// Raptor Parser class
pub type raptor_parser = raptor_parser_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raptor_serializer_s {
    _unused: [u8; 0],
}
/// raptor_serializer:
///
/// Raptor Serializer class
pub type raptor_serializer = raptor_serializer_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raptor_www_s {
    _unused: [u8; 0],
}
/// raptor_www:
///
/// Raptor WWW class
pub type raptor_www = raptor_www_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raptor_iostream_s {
    _unused: [u8; 0],
}
/// raptor_iostream:
///
/// Raptor I/O Stream class
pub type raptor_iostream = raptor_iostream_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raptor_xml_element_s {
    _unused: [u8; 0],
}
/// raptor_xml_element:
///
/// Raptor XML Element class
pub type raptor_xml_element = raptor_xml_element_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raptor_xml_writer_s {
    _unused: [u8; 0],
}
/// raptor_xml_writer:
///
/// Raptor XML Writer class
pub type raptor_xml_writer = raptor_xml_writer_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raptor_qname_s {
    _unused: [u8; 0],
}
/// raptor_qname:
///
/// Raptor XML qname class
pub type raptor_qname = raptor_qname_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raptor_namespace_s {
    _unused: [u8; 0],
}
/// raptor_namespace:
///
/// Raptor XML Namespace class
pub type raptor_namespace = raptor_namespace_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raptor_namespace_stack_s {
    _unused: [u8; 0],
}
/// raptor_namespace_stack:
///
/// Raptor XML Namespace Stack class
pub type raptor_namespace_stack = raptor_namespace_stack_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raptor_sax2_s {
    _unused: [u8; 0],
}
/// raptor_sax2:
///
/// Raptor SAX2 class
pub type raptor_sax2 = raptor_sax2_s;
/// raptor_type_q:
/// @mime_type: MIME type string
/// @mime_type_len: length of @mime_type
/// @q: Q value 0-10 standing for decimal 0.0-1.0
///
/// (MIME Type, Q) pair
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raptor_type_q {
    pub mime_type: *const libc::c_char,
    pub mime_type_len: usize,
    pub q: libc::c_uchar,
}
#[test]
fn bindgen_test_layout_raptor_type_q() {
    assert_eq!(
        ::std::mem::size_of::<raptor_type_q>(),
        24usize,
        concat!("Size of: ", stringify!(raptor_type_q))
    );
    assert_eq!(
        ::std::mem::align_of::<raptor_type_q>(),
        8usize,
        concat!("Alignment of ", stringify!(raptor_type_q))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raptor_type_q>())).mime_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_type_q),
            "::",
            stringify!(mime_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raptor_type_q>())).mime_type_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_type_q),
            "::",
            stringify!(mime_type_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raptor_type_q>())).q as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_type_q),
            "::",
            stringify!(q)
        )
    );
}
pub const raptor_syntax_bitflags_RAPTOR_SYNTAX_NEED_BASE_URI: raptor_syntax_bitflags = 1;
/// raptor_syntax_bitflags:
/// @RAPTOR_SYNTAX_NEED_BASE_URI: the syntax requires a base URI
///
/// Bit flags for #raptor_syntax_description flags field
pub type raptor_syntax_bitflags = u32;
/// raptor_syntax_description:
/// @names: array of syntax names - the first one (required) is the public name, the rest are aliases.  The array is NULL terminated.
/// @names_count: size of @names array
/// @label: long descriptive label for syntax
/// @mime_types: Array of (MIME type, Q) values associated with the syntax (or NULL).  If present the array is NULL terminated.
/// @mime_types_count: size of @mime_types array
/// @uri_strings: array of URIs identifying the syntax (or NULL). The first one if present is the main URI, the rest are aliases.  The array is NULL terminated.
/// @uri_strings_count: size of @uri_strings array
/// @flags: See #raptor_syntax_bitflags for the bits
///
/// Description of a syntax or file format.
///
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raptor_syntax_description {
    pub names: *const *const libc::c_char,
    pub names_count: libc::c_uint,
    pub label: *const libc::c_char,
    pub mime_types: *const raptor_type_q,
    pub mime_types_count: libc::c_uint,
    pub uri_strings: *const *const libc::c_char,
    pub uri_strings_count: libc::c_uint,
    pub flags: libc::c_uint,
}
#[test]
fn bindgen_test_layout_raptor_syntax_description() {
    assert_eq!(
        ::std::mem::size_of::<raptor_syntax_description>(),
        56usize,
        concat!("Size of: ", stringify!(raptor_syntax_description))
    );
    assert_eq!(
        ::std::mem::align_of::<raptor_syntax_description>(),
        8usize,
        concat!("Alignment of ", stringify!(raptor_syntax_description))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raptor_syntax_description>())).names as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_syntax_description),
            "::",
            stringify!(names)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<raptor_syntax_description>())).names_count as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_syntax_description),
            "::",
            stringify!(names_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raptor_syntax_description>())).label as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_syntax_description),
            "::",
            stringify!(label)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<raptor_syntax_description>())).mime_types as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_syntax_description),
            "::",
            stringify!(mime_types)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<raptor_syntax_description>())).mime_types_count as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_syntax_description),
            "::",
            stringify!(mime_types_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<raptor_syntax_description>())).uri_strings as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_syntax_description),
            "::",
            stringify!(uri_strings)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<raptor_syntax_description>())).uri_strings_count as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_syntax_description),
            "::",
            stringify!(uri_strings_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raptor_syntax_description>())).flags as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_syntax_description),
            "::",
            stringify!(flags)
        )
    );
}
pub const raptor_term_type_RAPTOR_TERM_TYPE_UNKNOWN: raptor_term_type = 0;
pub const raptor_term_type_RAPTOR_TERM_TYPE_URI: raptor_term_type = 1;
pub const raptor_term_type_RAPTOR_TERM_TYPE_LITERAL: raptor_term_type = 2;
pub const raptor_term_type_RAPTOR_TERM_TYPE_BLANK: raptor_term_type = 4;
/// raptor_term_type:
/// @RAPTOR_TERM_TYPE_URI: RDF URI
/// @RAPTOR_TERM_TYPE_LITERAL: RDF literal
/// @RAPTOR_TERM_TYPE_BLANK: RDF blank node
/// @RAPTOR_TERM_TYPE_UNKNOWN: Internal
///
/// Type of term in a #raptor_statement
///
/// Node type 3 is unused but exists to preserve numeric compatibility
/// with librdf_node_type values.
pub type raptor_term_type = u32;
/// raptor_locator:
/// @uri: URI of location (or NULL)
/// @file: Filename of location (or NULL)
/// @line: Line number of location (or <0 for no line)
/// @column: Column number of location (or <0 for no column)
/// @byte: Byte number of location (or <0 for no byte)
///
/// Location information for an error, warning or information message.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raptor_locator {
    pub uri: *mut raptor_uri,
    pub file: *const libc::c_char,
    pub line: libc::c_int,
    pub column: libc::c_int,
    pub byte: libc::c_int,
}
#[test]
fn bindgen_test_layout_raptor_locator() {
    assert_eq!(
        ::std::mem::size_of::<raptor_locator>(),
        32usize,
        concat!("Size of: ", stringify!(raptor_locator))
    );
    assert_eq!(
        ::std::mem::align_of::<raptor_locator>(),
        8usize,
        concat!("Alignment of ", stringify!(raptor_locator))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raptor_locator>())).uri as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_locator),
            "::",
            stringify!(uri)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raptor_locator>())).file as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_locator),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raptor_locator>())).line as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_locator),
            "::",
            stringify!(line)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raptor_locator>())).column as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_locator),
            "::",
            stringify!(column)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raptor_locator>())).byte as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_locator),
            "::",
            stringify!(byte)
        )
    );
}
pub const raptor_option_RAPTOR_OPTION_SCANNING: raptor_option = 0;
pub const raptor_option_RAPTOR_OPTION_ALLOW_NON_NS_ATTRIBUTES: raptor_option = 1;
pub const raptor_option_RAPTOR_OPTION_ALLOW_OTHER_PARSETYPES: raptor_option = 2;
pub const raptor_option_RAPTOR_OPTION_ALLOW_BAGID: raptor_option = 3;
pub const raptor_option_RAPTOR_OPTION_ALLOW_RDF_TYPE_RDF_LIST: raptor_option = 4;
pub const raptor_option_RAPTOR_OPTION_NORMALIZE_LANGUAGE: raptor_option = 5;
pub const raptor_option_RAPTOR_OPTION_NON_NFC_FATAL: raptor_option = 6;
pub const raptor_option_RAPTOR_OPTION_WARN_OTHER_PARSETYPES: raptor_option = 7;
pub const raptor_option_RAPTOR_OPTION_CHECK_RDF_ID: raptor_option = 8;
pub const raptor_option_RAPTOR_OPTION_RELATIVE_URIS: raptor_option = 9;
pub const raptor_option_RAPTOR_OPTION_WRITER_AUTO_INDENT: raptor_option = 10;
pub const raptor_option_RAPTOR_OPTION_WRITER_AUTO_EMPTY: raptor_option = 11;
pub const raptor_option_RAPTOR_OPTION_WRITER_INDENT_WIDTH: raptor_option = 12;
pub const raptor_option_RAPTOR_OPTION_WRITER_XML_VERSION: raptor_option = 13;
pub const raptor_option_RAPTOR_OPTION_WRITER_XML_DECLARATION: raptor_option = 14;
pub const raptor_option_RAPTOR_OPTION_NO_NET: raptor_option = 15;
pub const raptor_option_RAPTOR_OPTION_RESOURCE_BORDER: raptor_option = 16;
pub const raptor_option_RAPTOR_OPTION_LITERAL_BORDER: raptor_option = 17;
pub const raptor_option_RAPTOR_OPTION_BNODE_BORDER: raptor_option = 18;
pub const raptor_option_RAPTOR_OPTION_RESOURCE_FILL: raptor_option = 19;
pub const raptor_option_RAPTOR_OPTION_LITERAL_FILL: raptor_option = 20;
pub const raptor_option_RAPTOR_OPTION_BNODE_FILL: raptor_option = 21;
pub const raptor_option_RAPTOR_OPTION_HTML_TAG_SOUP: raptor_option = 22;
pub const raptor_option_RAPTOR_OPTION_MICROFORMATS: raptor_option = 23;
pub const raptor_option_RAPTOR_OPTION_HTML_LINK: raptor_option = 24;
pub const raptor_option_RAPTOR_OPTION_WWW_TIMEOUT: raptor_option = 25;
pub const raptor_option_RAPTOR_OPTION_WRITE_BASE_URI: raptor_option = 26;
pub const raptor_option_RAPTOR_OPTION_WWW_HTTP_CACHE_CONTROL: raptor_option = 27;
pub const raptor_option_RAPTOR_OPTION_WWW_HTTP_USER_AGENT: raptor_option = 28;
pub const raptor_option_RAPTOR_OPTION_JSON_CALLBACK: raptor_option = 29;
pub const raptor_option_RAPTOR_OPTION_JSON_EXTRA_DATA: raptor_option = 30;
pub const raptor_option_RAPTOR_OPTION_RSS_TRIPLES: raptor_option = 31;
pub const raptor_option_RAPTOR_OPTION_ATOM_ENTRY_URI: raptor_option = 32;
pub const raptor_option_RAPTOR_OPTION_PREFIX_ELEMENTS: raptor_option = 33;
pub const raptor_option_RAPTOR_OPTION_STRICT: raptor_option = 34;
pub const raptor_option_RAPTOR_OPTION_WWW_CERT_FILENAME: raptor_option = 35;
pub const raptor_option_RAPTOR_OPTION_WWW_CERT_TYPE: raptor_option = 36;
pub const raptor_option_RAPTOR_OPTION_WWW_CERT_PASSPHRASE: raptor_option = 37;
pub const raptor_option_RAPTOR_OPTION_NO_FILE: raptor_option = 38;
pub const raptor_option_RAPTOR_OPTION_WWW_SSL_VERIFY_PEER: raptor_option = 39;
pub const raptor_option_RAPTOR_OPTION_WWW_SSL_VERIFY_HOST: raptor_option = 40;
pub const raptor_option_RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES: raptor_option = 41;
pub const raptor_option_RAPTOR_OPTION_LAST: raptor_option = 41;
/// raptor_option:
/// @RAPTOR_OPTION_SCANNING: If true (default false), the RDF/XML
///   parser will look for embedded rdf:RDF elements inside the XML
///   content, and not require that the XML start with an rdf:RDF root
///   element.
/// @RAPTOR_OPTION_ALLOW_NON_NS_ATTRIBUTES: If true (default true)
///   then the RDF/XML parser will allow non-XML namespaced attributes
///   to be accepted as well as rdf: namespaced ones.  For example,
///   'about' and 'ID' will be interpreted as if they were rdf:about
///   and rdf:ID respectively.
/// @RAPTOR_OPTION_ALLOW_OTHER_PARSETYPES: If true (default true)
///   then the RDF/XML parser will allow unknown parsetypes to be
///   present and will pass them on to the user.  Unimplemented at
///   present.
/// @RAPTOR_OPTION_ALLOW_BAGID: If true (default true) then the
///   RDF/XML parser will support the rdf:bagID attribute that was
///   removed from the RDF/XML language when it was revised.  This
///   support may be removed in future.
/// @RAPTOR_OPTION_ALLOW_RDF_TYPE_RDF_LIST: If true (default false)
///   then the RDF/XML parser will generate the idList rdf:type
///   rdf:List triple in the handling of rdf:parseType="Collection".
///   This triple was removed during the revising of RDF/XML after
///   collections were initially added.
/// @RAPTOR_OPTION_NORMALIZE_LANGUAGE: If true (default true) then
///   XML language values such as from xml:lang will be normalized to
///   lowercase.
/// @RAPTOR_OPTION_NON_NFC_FATAL: If true (default false) then
///  illegal Unicode Normal Form C in literals will give a fatal
///  error, otherwise just a warning.
/// @RAPTOR_OPTION_WARN_OTHER_PARSETYPES: If true (default true) then
///   the RDF/XML parser will warn about unknown rdf:parseType values.
/// @RAPTOR_OPTION_CHECK_RDF_ID: If true (default true) then the
///   RDF/XML will check rdf:ID attribute values for duplicates and
///   cause an error if any are found.
/// @RAPTOR_OPTION_RELATIVE_URIS: If true (default true) then
///   relative URIs will be used wherever possible when serializing.
/// @RAPTOR_OPTION_WRITER_AUTO_INDENT: Automatically indent elements when
///   seriailizing.
/// @RAPTOR_OPTION_WRITER_AUTO_EMPTY: Automatically detect and
///   abbreviate empty elements when serializing.
/// @RAPTOR_OPTION_WRITER_INDENT_WIDTH: Integer number of spaces to use
///   for each indent level when serializing with auto indent.
/// @RAPTOR_OPTION_WRITER_XML_VERSION: Integer XML version XML 1.0 (10) or XML 1.1 (11)
/// @RAPTOR_OPTION_WRITER_XML_DECLARATION: Write XML 1.0 or 1.1 declaration.
/// @RAPTOR_OPTION_NO_NET: Deny network requests inside other requests.
/// @RAPTOR_OPTION_RESOURCE_BORDER: Border color of resource
///   nodes for GraphViz DOT serializer.
/// @RAPTOR_OPTION_LITERAL_BORDER: Border color of literal nodes
///   for GraphViz DOT serializer.
/// @RAPTOR_OPTION_BNODE_BORDER: Border color of blank nodes for
///   GraphViz DOT serializer.
/// @RAPTOR_OPTION_RESOURCE_FILL: Fill color of resource nodes
///   for GraphViz DOT serializer.
/// @RAPTOR_OPTION_LITERAL_FILL: Fill color of literal nodes for
///   GraphViz DOT serializer.
/// @RAPTOR_OPTION_BNODE_FILL: Fill color of blank nodes for
///   GraphViz DOT serializer.
/// @RAPTOR_OPTION_HTML_TAG_SOUP: Use a lax HTML parser if an XML parser
///   fails when read HTML for GRDDL parser.
/// @RAPTOR_OPTION_MICROFORMATS: Look for microformats for GRDDL parser.
/// @RAPTOR_OPTION_HTML_LINK: Look for head &lt;link&gt; to type rdf/xml
///   for GRDDL parser.
/// @RAPTOR_OPTION_WWW_TIMEOUT: Set timeout for internal WWW URI requests
///   for GRDDL parser.
/// @RAPTOR_OPTION_WRITE_BASE_URI: Write @base directive for Turtle/N3.
/// @RAPTOR_OPTION_WWW_HTTP_CACHE_CONTROL: HTTP Cache-Control: header
/// @RAPTOR_OPTION_WWW_HTTP_USER_AGENT: HTTP User-Agent: header
/// @RAPTOR_OPTION_JSON_CALLBACK: JSON serializer callback function.
/// @RAPTOR_OPTION_JSON_EXTRA_DATA: JSON serializer extra top-level data
/// @RAPTOR_OPTION_RSS_TRIPLES: Atom/RSS serializer writes extra RDF triples it finds (none, rdf-xml, atom-triples)
/// @RAPTOR_OPTION_ATOM_ENTRY_URI: Atom entry URI.  If given, generate an Atom Entry Document with the item having the given URI, otherwise generate an Atom Feed Document with any items found.
/// @RAPTOR_OPTION_PREFIX_ELEMENTS: Integer. If set, generate Atom/RSS1.0 documents with prefixed elements, otherwise unprefixed.
/// @RAPTOR_OPTION_STRICT: Boolean. If set, operate in strict conformance mode.
/// @RAPTOR_OPTION_WWW_CERT_FILENAME: String. SSL client certificate filename
/// @RAPTOR_OPTION_WWW_CERT_TYPE: String. SSL client certificate type
/// @RAPTOR_OPTION_WWW_CERT_PASSPHRASE: String. SSL client certificate passphrase
/// @RAPTOR_OPTION_WWW_SSL_VERIFY_PEER:  Integer. SSL verify peer - non-0 to verify peer SSL certificate (default)
/// @RAPTOR_OPTION_WWW_SSL_VERIFY_HOST: Integer. SSL verify host - 0 none, 1 CN match, 2 host match (default). Other values are ignored.
/// @RAPTOR_OPTION_NO_FILE: Deny file reading requests inside other requests.
/// @RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES: When reading XML, load external entities.
/// @RAPTOR_OPTION_LAST: Internal
///
/// Raptor parser, serializer or XML writer options.
pub type raptor_option = u32;
/// raptor_term_literal_value:
/// @string: literal string
/// @string_len: length of string
/// @datatype: datatype URI (or NULL)
/// @language: literal language (or NULL)
/// @language_len: length of language
///
/// Literal term value - this typedef exists solely for use in #raptor_term
///
/// Either @datatype or @language may be non-NULL but not both.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raptor_term_literal_value {
    pub string: *mut libc::c_uchar,
    pub string_len: libc::c_uint,
    pub datatype: *mut raptor_uri,
    pub language: *mut libc::c_uchar,
    pub language_len: libc::c_uchar,
}
#[test]
fn bindgen_test_layout_raptor_term_literal_value() {
    assert_eq!(
        ::std::mem::size_of::<raptor_term_literal_value>(),
        40usize,
        concat!("Size of: ", stringify!(raptor_term_literal_value))
    );
    assert_eq!(
        ::std::mem::align_of::<raptor_term_literal_value>(),
        8usize,
        concat!("Alignment of ", stringify!(raptor_term_literal_value))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<raptor_term_literal_value>())).string as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_term_literal_value),
            "::",
            stringify!(string)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<raptor_term_literal_value>())).string_len as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_term_literal_value),
            "::",
            stringify!(string_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<raptor_term_literal_value>())).datatype as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_term_literal_value),
            "::",
            stringify!(datatype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<raptor_term_literal_value>())).language as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_term_literal_value),
            "::",
            stringify!(language)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<raptor_term_literal_value>())).language_len as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_term_literal_value),
            "::",
            stringify!(language_len)
        )
    );
}
/// raptor_term_blank_value:
/// @string: literal string
/// @string_len: length of string
///
/// Blank term value - this typedef exists solely for use in #raptor_term
///
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raptor_term_blank_value {
    pub string: *mut libc::c_uchar,
    pub string_len: libc::c_uint,
}
#[test]
fn bindgen_test_layout_raptor_term_blank_value() {
    assert_eq!(
        ::std::mem::size_of::<raptor_term_blank_value>(),
        16usize,
        concat!("Size of: ", stringify!(raptor_term_blank_value))
    );
    assert_eq!(
        ::std::mem::align_of::<raptor_term_blank_value>(),
        8usize,
        concat!("Alignment of ", stringify!(raptor_term_blank_value))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raptor_term_blank_value>())).string as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_term_blank_value),
            "::",
            stringify!(string)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<raptor_term_blank_value>())).string_len as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_term_blank_value),
            "::",
            stringify!(string_len)
        )
    );
}
/// raptor_term_value:
/// @uri: uri value when term type is #RAPTOR_TERM_TYPE_URI
/// @literal: literal value when term type is #RAPTOR_TERM_TYPE_LITERAL
/// @blank: blank value when term type is #RAPTOR_TERM_TYPE_BLANK
///
/// Term value - this typedef exists solely for use in #raptor_term
///
#[repr(C)]
#[derive(Copy, Clone)]
pub union raptor_term_value {
    pub uri: *mut raptor_uri,
    pub literal: raptor_term_literal_value,
    pub blank: raptor_term_blank_value,
    _bindgen_union_align: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_raptor_term_value() {
    assert_eq!(
        ::std::mem::size_of::<raptor_term_value>(),
        40usize,
        concat!("Size of: ", stringify!(raptor_term_value))
    );
    assert_eq!(
        ::std::mem::align_of::<raptor_term_value>(),
        8usize,
        concat!("Alignment of ", stringify!(raptor_term_value))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raptor_term_value>())).uri as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_term_value),
            "::",
            stringify!(uri)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raptor_term_value>())).literal as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_term_value),
            "::",
            stringify!(literal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raptor_term_value>())).blank as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_term_value),
            "::",
            stringify!(blank)
        )
    );
}
/// raptor_term:
/// @world: world
/// @usage: usage reference count (if >0)
/// @type: term type
/// @value: term values per type
///
/// An RDF statement term
///
#[repr(C)]
#[derive(Copy, Clone)]
pub struct raptor_term {
    pub world: *mut raptor_world,
    pub usage: libc::c_int,
    pub type_: raptor_term_type,
    pub value: raptor_term_value,
}
#[test]
fn bindgen_test_layout_raptor_term() {
    assert_eq!(
        ::std::mem::size_of::<raptor_term>(),
        56usize,
        concat!("Size of: ", stringify!(raptor_term))
    );
    assert_eq!(
        ::std::mem::align_of::<raptor_term>(),
        8usize,
        concat!("Alignment of ", stringify!(raptor_term))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raptor_term>())).world as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_term),
            "::",
            stringify!(world)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raptor_term>())).usage as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_term),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raptor_term>())).type_ as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_term),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raptor_term>())).value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_term),
            "::",
            stringify!(value)
        )
    );
}
/// raptor_statement:
/// @world: world pointer
/// @usage: usage count
/// @subject: statement subject
/// @predicate: statement predicate
/// @object: statement object
/// @graph: statement graph name (or NULL if not present)
///
/// An RDF triple with optional graph name (quad)
///
/// See #raptor_term for a description of how the fields may be used.
/// As returned by a parser statement_handler.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raptor_statement {
    pub world: *mut raptor_world,
    pub usage: libc::c_int,
    pub subject: *mut raptor_term,
    pub predicate: *mut raptor_term,
    pub object: *mut raptor_term,
    pub graph: *mut raptor_term,
}
#[test]
fn bindgen_test_layout_raptor_statement() {
    assert_eq!(
        ::std::mem::size_of::<raptor_statement>(),
        48usize,
        concat!("Size of: ", stringify!(raptor_statement))
    );
    assert_eq!(
        ::std::mem::align_of::<raptor_statement>(),
        8usize,
        concat!("Alignment of ", stringify!(raptor_statement))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raptor_statement>())).world as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_statement),
            "::",
            stringify!(world)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raptor_statement>())).usage as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_statement),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raptor_statement>())).subject as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_statement),
            "::",
            stringify!(subject)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raptor_statement>())).predicate as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_statement),
            "::",
            stringify!(predicate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raptor_statement>())).object as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_statement),
            "::",
            stringify!(object)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raptor_statement>())).graph as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_statement),
            "::",
            stringify!(graph)
        )
    );
}
pub const raptor_log_level_RAPTOR_LOG_LEVEL_NONE: raptor_log_level = 0;
pub const raptor_log_level_RAPTOR_LOG_LEVEL_TRACE: raptor_log_level = 1;
pub const raptor_log_level_RAPTOR_LOG_LEVEL_DEBUG: raptor_log_level = 2;
pub const raptor_log_level_RAPTOR_LOG_LEVEL_INFO: raptor_log_level = 3;
pub const raptor_log_level_RAPTOR_LOG_LEVEL_WARN: raptor_log_level = 4;
pub const raptor_log_level_RAPTOR_LOG_LEVEL_ERROR: raptor_log_level = 5;
pub const raptor_log_level_RAPTOR_LOG_LEVEL_FATAL: raptor_log_level = 6;
pub const raptor_log_level_RAPTOR_LOG_LEVEL_LAST: raptor_log_level = 6;
/// raptor_log_level:
/// @RAPTOR_LOG_LEVEL_NONE: Internal
/// @RAPTOR_LOG_LEVEL_TRACE: very fine-grained tracing messages information
/// @RAPTOR_LOG_LEVEL_DEBUG: fine-grained tracing messages suitable for debugging
/// @RAPTOR_LOG_LEVEL_INFO: coarse-grained information messages
/// @RAPTOR_LOG_LEVEL_WARN: warning messages of potentially harmful problems
/// @RAPTOR_LOG_LEVEL_ERROR: error messages where the application can continue
/// @RAPTOR_LOG_LEVEL_FATAL: fatal error message where the application will likely abort
/// @RAPTOR_LOG_LEVEL_LAST: Internal
///
/// Log levels
pub type raptor_log_level = u32;
pub const raptor_domain_RAPTOR_DOMAIN_NONE: raptor_domain = 0;
pub const raptor_domain_RAPTOR_DOMAIN_IOSTREAM: raptor_domain = 1;
pub const raptor_domain_RAPTOR_DOMAIN_NAMESPACE: raptor_domain = 2;
pub const raptor_domain_RAPTOR_DOMAIN_PARSER: raptor_domain = 3;
pub const raptor_domain_RAPTOR_DOMAIN_QNAME: raptor_domain = 4;
pub const raptor_domain_RAPTOR_DOMAIN_SAX2: raptor_domain = 5;
pub const raptor_domain_RAPTOR_DOMAIN_SERIALIZER: raptor_domain = 6;
pub const raptor_domain_RAPTOR_DOMAIN_TERM: raptor_domain = 7;
pub const raptor_domain_RAPTOR_DOMAIN_TURTLE_WRITER: raptor_domain = 8;
pub const raptor_domain_RAPTOR_DOMAIN_URI: raptor_domain = 9;
pub const raptor_domain_RAPTOR_DOMAIN_WORLD: raptor_domain = 10;
pub const raptor_domain_RAPTOR_DOMAIN_WWW: raptor_domain = 11;
pub const raptor_domain_RAPTOR_DOMAIN_XML_WRITER: raptor_domain = 12;
pub const raptor_domain_RAPTOR_DOMAIN_LAST: raptor_domain = 12;
/// raptor_domain:
/// @RAPTOR_DOMAIN_IOSTREAM: I/O stream
/// @RAPTOR_DOMAIN_NAMESPACE: XML Namespace / namespace stack
/// @RAPTOR_DOMAIN_PARSER: RDF Parser
/// @RAPTOR_DOMAIN_QNAME: XML QName
/// @RAPTOR_DOMAIN_SAX2:  XML SAX2
/// @RAPTOR_DOMAIN_SERIALIZER: RDF Serializer
/// @RAPTOR_DOMAIN_TERM: RDF Term
/// @RAPTOR_DOMAIN_TURTLE_WRITER: Turtle Writer
/// @RAPTOR_DOMAIN_URI: RDF Uri
/// @RAPTOR_DOMAIN_WORLD: RDF world
/// @RAPTOR_DOMAIN_WWW: WWW
/// @RAPTOR_DOMAIN_XML_WRITER: XML Writer
/// @RAPTOR_DOMAIN_NONE: Internal
/// @RAPTOR_DOMAIN_LAST: Internal
///
/// Log domain
pub type raptor_domain = u32;
/// raptor_log_message:
/// @code: error code or < 0 if not used or known
/// @domain: message domain or #RAPTOR_DOMAIN_NONE if not used or known
/// @level: log message level
/// @locator: location associated with message or NULL if not known
/// @text: message string
///
/// Log message.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raptor_log_message {
    pub code: libc::c_int,
    pub domain: raptor_domain,
    pub level: raptor_log_level,
    pub locator: *mut raptor_locator,
    pub text: *const libc::c_char,
}
#[test]
fn bindgen_test_layout_raptor_log_message() {
    assert_eq!(
        ::std::mem::size_of::<raptor_log_message>(),
        32usize,
        concat!("Size of: ", stringify!(raptor_log_message))
    );
    assert_eq!(
        ::std::mem::align_of::<raptor_log_message>(),
        8usize,
        concat!("Alignment of ", stringify!(raptor_log_message))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raptor_log_message>())).code as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_log_message),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raptor_log_message>())).domain as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_log_message),
            "::",
            stringify!(domain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raptor_log_message>())).level as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_log_message),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raptor_log_message>())).locator as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_log_message),
            "::",
            stringify!(locator)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raptor_log_message>())).text as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_log_message),
            "::",
            stringify!(text)
        )
    );
}
/// raptor_log_handler:
/// @user_data: user data
/// @message: log message
///
/// Handler function for log messages with location
///
/// Used during parsing and serializing for errors and warnings that
/// may include location information. Handlers may be set
/// by raptor_world_set_log_handler().
///
pub type raptor_log_handler = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut libc::c_void, message: *mut raptor_log_message),
>;
/// raptor_statement_handler:
/// @user_data: user data
/// @statement: statement to report
///
/// Statement (triple) reporting handler function.
///
/// This handler function set with
/// raptor_parser_set_statement_handler() on a parser receives
/// statements as the parsing proceeds. The @statement argument to the
/// handler is shared and must be copied by the caller with
/// raptor_statement_copy().
pub type raptor_statement_handler = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut libc::c_void, statement: *mut raptor_statement),
>;
pub const raptor_graph_mark_flags_RAPTOR_GRAPH_MARK_START: raptor_graph_mark_flags = 1;
pub const raptor_graph_mark_flags_RAPTOR_GRAPH_MARK_DECLARED: raptor_graph_mark_flags = 2;
/// raptor_graph_mark_flags:
/// @RAPTOR_GRAPH_MARK_START: mark is start of graph (otherwise is end)
/// @RAPTOR_GRAPH_MARK_DECLARED: mark was declared in syntax rather than implict
///
/// Graph mark handler bitmask flags
pub type raptor_graph_mark_flags = u32;
/// raptor_graph_mark_handler:
/// @user_data: user data
/// @graph: graph to report, NULL for the default graph
/// @flags: bitmask of #raptor_graph_mark_flags flags
///
/// Graph start/end mark handler function.
///
/// Records start and end of graphs happening in a stream of generated
/// #raptor_statement via the statement handler.  The callback starts a
/// graph when @flags has #RAPTOR_GRAPH_MARK_START bit set.
///
/// The start and ends may be either declared in the syntax via some
/// keyword or mechanism such as TRiG {} syntax when @flags has bit
/// #RAPTOR_GRAPH_MARK_DECLARED set, or be implied by the start/end of
/// the data in other syntaxes, and the bit will be unset.
pub type raptor_graph_mark_handler = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut libc::c_void, graph: *mut raptor_uri, flags: libc::c_int),
>;
/// raptor_generate_bnodeid_handler:
/// @user_data: user data
/// @user_bnodeid: a user-specified ID or NULL if none available.
///
/// Generate a blank node identifier handler function.
///
/// Return value: new blank node ID to use
pub type raptor_generate_bnodeid_handler = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut libc::c_void, user_bnodeid: *mut libc::c_uchar)
        -> *mut libc::c_uchar,
>;
/// raptor_namespace_handler:
/// @user_data: user data
/// @nspace: #raptor_namespace declared
///
/// XML Namespace declaration reporting handler set by
/// raptor_parser_set_namespace_handler().
pub type raptor_namespace_handler = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut libc::c_void, nspace: *mut raptor_namespace),
>;
/// raptor_www_write_bytes_handler:
/// @www: WWW object
/// @userdata: user data
/// @ptr: data pointer
/// @size: size of individual item
/// @nmemb: number of items
///
/// Receiving bytes of data from WWW retrieval handler.
///
/// Set by raptor_www_set_write_bytes_handler().
pub type raptor_www_write_bytes_handler = ::std::option::Option<
    unsafe extern "C" fn(
        www: *mut raptor_www,
        userdata: *mut libc::c_void,
        ptr: *const libc::c_void,
        size: usize,
        nmemb: usize,
    ),
>;
/// raptor_www_content_type_handler:
/// @www: WWW object
/// @userdata: user data
/// @content_type: content type seen
///
/// Receiving Content-Type: header from WWW retrieval handler.
///
/// Set by raptor_www_set_content_type_handler().
pub type raptor_www_content_type_handler = ::std::option::Option<
    unsafe extern "C" fn(
        www: *mut raptor_www,
        userdata: *mut libc::c_void,
        content_type: *const libc::c_char,
    ),
>;
/// raptor_www_final_uri_handler:
/// @www: WWW object
/// @userdata: user data
/// @final_uri: final URI seen
///
/// Receiving the final resolved URI from a WWW retrieval
///
/// Set by raptor_www_set_final_uri_handler().
pub type raptor_www_final_uri_handler = ::std::option::Option<
    unsafe extern "C" fn(
        www: *mut raptor_www,
        userdata: *mut libc::c_void,
        final_uri: *mut raptor_uri,
    ),
>;
/// raptor_uri_filter_func:
/// @user_data: user data
/// @uri: #raptor_uri URI to check
///
/// Callback function for #raptor_www_set_uri_filter
///
/// Return value: non-0 to filter the URI
pub type raptor_uri_filter_func = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut libc::c_void, uri: *mut raptor_uri) -> libc::c_int,
>;
pub const raptor_world_flag_RAPTOR_WORLD_FLAG_LIBXML_GENERIC_ERROR_SAVE: raptor_world_flag = 1;
pub const raptor_world_flag_RAPTOR_WORLD_FLAG_LIBXML_STRUCTURED_ERROR_SAVE: raptor_world_flag = 2;
pub const raptor_world_flag_RAPTOR_WORLD_FLAG_URI_INTERNING: raptor_world_flag = 3;
pub const raptor_world_flag_RAPTOR_WORLD_FLAG_WWW_SKIP_INIT_FINISH: raptor_world_flag = 4;
/// raptor_world_flag:
/// @RAPTOR_WORLD_FLAG_LIBXML_GENERIC_ERROR_SAVE: if set (non-0 value) - save/restore the libxml generic error handler when raptor library initializes (default set)
/// @RAPTOR_WORLD_FLAG_LIBXML_STRUCTURED_ERROR_SAVE: if set (non-0 value) - save/restore the libxml structured error handler when raptor library terminates (default set)
/// @RAPTOR_WORLD_FLAG_URI_INTERNING: if set (non-0 value) - each URI is saved interned in-memory and reused (default set)
/// @RAPTOR_WORLD_FLAG_WWW_SKIP_INIT_FINISH: if set (non-0 value) the raptor will neither initialise or terminate the lower level WWW library.  Usually in raptor initialising either curl_global_init (for libcurl) are called and in raptor cleanup, curl_global_cleanup is called.   This flag allows the application finer control over these libraries such as setting other global options or potentially calling and terminating raptor several times.  It does mean that applications which use this call must do their own extra work in order to allocate and free all resources to the system.
///
/// Raptor world flags
///
/// These are used by raptor_world_set_flags() to control raptor-wide
/// options across classes.  These must be set before
/// raptor_world_open() is called explicitly or implicitly (by
/// creating a raptor object).  There is no enumeration function for
/// these flags because they are not user options and must be set
/// before the library is initialised.  For similar reasons, there is
/// no get function.
///
/// If any libxml handler saving/restoring is enabled, any existing
/// handler and context is saved before parsing and restored
/// afterwards.  Otherwise, no saving/restoring is performed.
///
pub type raptor_world_flag = u32;
/// raptor_data_compare_arg_handler:
/// @data1: first object
/// @data2: second object
/// @user_data: user data argument
///
/// Function to compare two data objects with a user data argument
///
/// Designed to be used with raptor_sort_r() and compatible functions
/// such as raptor_sequence_sort_r() which uses it.
///
/// Return value: compare value <0 if @data1 is before @data2, =0 if equal, >0 if @data1 is after @data2
pub type raptor_data_compare_arg_handler = ::std::option::Option<
    unsafe extern "C" fn(
        data1: *const libc::c_void,
        data2: *const libc::c_void,
        user_data: *mut libc::c_void,
    ) -> libc::c_int,
>;
/// raptor_data_compare_handler:
/// @data1: first data object
/// @data2: second data object
///
/// Function to compare two data objects - signature like strcmp() and function pssed to qsort()
///
/// Designed to be passed into generic data structure constructors
/// like raptor_new_avltree().
///
/// Return value: compare value <0 if @data1 is before @data2, =0 if equal, >0 if @data1 is after @data2
pub type raptor_data_compare_handler = ::std::option::Option<
    unsafe extern "C" fn(data1: *const libc::c_void, data2: *const libc::c_void) -> libc::c_int,
>;
/// raptor_data_malloc_handler:
/// @size: data size
///
/// Typedef for a function to allocate memory - signature like malloc()
///
/// Designed to be passed into constructors
/// like raptor_www_fetch_to_string
///
/// Return value: pointer to newly allocated memory or NULL on failure
pub type raptor_data_malloc_handler =
    ::std::option::Option<unsafe extern "C" fn(size: usize) -> *mut libc::c_void>;
/// raptor_data_free_handler:
/// @data: data object or NULL
///
/// Typedef for function to free a data object - signature like free()
///
/// Designed to be passed into generic data structure constructors
/// like raptor_new_avltree().  If @data is NULL, nothing should be done.
pub type raptor_data_free_handler =
    ::std::option::Option<unsafe extern "C" fn(data: *mut libc::c_void)>;
/// raptor_data_context_free_handler:
/// @context: context data for the free function
/// @object: object to free
///
/// Handler function for freeing a sequence item with a contextual pointer.
///
/// Set by raptor_new_sequence_with_context().
pub type raptor_data_context_free_handler = ::std::option::Option<
    unsafe extern "C" fn(context: *mut libc::c_void, object: *mut libc::c_void),
>;
/// raptor_data_print_handler:
/// @object: object to print
/// @fh: FILE* to print to
///
/// Handler function for printing an object to a stream.
///
/// Set by raptor_new_sequence()
///
/// Return value: non-0 on failure
pub type raptor_data_print_handler = ::std::option::Option<
    unsafe extern "C" fn(object: *mut libc::c_void, fh: *mut FILE) -> libc::c_int,
>;
/// raptor_data_context_print_handler:
/// @context: context data for the print function
/// @object: object to print
/// @fh: FILE* to print to
///
/// Function function for printing an object with data context to a stream.
///
/// Set by raptor_new_sequence_with_context()
///
/// Return value: non-0 on failure
pub type raptor_data_context_print_handler = ::std::option::Option<
    unsafe extern "C" fn(context: *mut libc::c_void, object: *mut libc::c_void, fh: *mut FILE)
        -> libc::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raptor_stringbuffer_s {
    _unused: [u8; 0],
}
/// raptor_stringbuffer:
///
/// Raptor string buffer class
pub type raptor_stringbuffer = raptor_stringbuffer_s;
extern "C" {
    pub fn raptor_new_world_internal(version_decimal: libc::c_uint) -> *mut raptor_world;
}
extern "C" {
    pub fn raptor_world_open(world: *mut raptor_world) -> libc::c_int;
}
extern "C" {
    pub fn raptor_free_world(world: *mut raptor_world);
}
extern "C" {
    pub fn raptor_world_set_libxslt_security_preferences(
        world: *mut raptor_world,
        security_preferences: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_world_set_flag(
        world: *mut raptor_world,
        flag: raptor_world_flag,
        value: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_world_set_log_handler(
        world: *mut raptor_world,
        user_data: *mut libc::c_void,
        handler: raptor_log_handler,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_world_set_generate_bnodeid_handler(
        world: *mut raptor_world,
        user_data: *mut libc::c_void,
        handler: raptor_generate_bnodeid_handler,
    );
}
extern "C" {
    pub fn raptor_world_generate_bnodeid(world: *mut raptor_world) -> *mut libc::c_uchar;
}
extern "C" {
    pub fn raptor_world_set_generate_bnodeid_parameters(
        world: *mut raptor_world,
        prefix: *mut libc::c_char,
        base: libc::c_int,
    );
}
extern "C" {
    pub fn raptor_log_level_get_label(level: raptor_log_level) -> *const libc::c_char;
}
extern "C" {
    pub fn raptor_domain_get_label(domain: raptor_domain) -> *const libc::c_char;
}
extern "C" {
    pub fn raptor_world_is_parser_name(
        world: *mut raptor_world,
        name: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_world_guess_parser_name(
        world: *mut raptor_world,
        uri: *mut raptor_uri,
        mime_type: *const libc::c_char,
        buffer: *const libc::c_uchar,
        len: usize,
        identifier: *const libc::c_uchar,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn raptor_world_is_serializer_name(
        world: *mut raptor_world,
        name: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_world_get_parsers_count(world: *mut raptor_world) -> libc::c_int;
}
extern "C" {
    pub fn raptor_world_get_serializers_count(world: *mut raptor_world) -> libc::c_int;
}
extern "C" {
    pub fn raptor_world_get_parser_description(
        world: *mut raptor_world,
        counter: libc::c_uint,
    ) -> *const raptor_syntax_description;
}
extern "C" {
    pub fn raptor_world_get_serializer_description(
        world: *mut raptor_world,
        counter: libc::c_uint,
    ) -> *const raptor_syntax_description;
}
extern "C" {
    pub fn raptor_syntax_description_validate(desc: *mut raptor_syntax_description) -> libc::c_int;
}
extern "C" {
    pub fn raptor_world_get_option_from_uri(
        world: *mut raptor_world,
        uri: *mut raptor_uri,
    ) -> raptor_option;
}
extern "C" {
    pub fn raptor_new_term_from_uri(
        world: *mut raptor_world,
        uri: *mut raptor_uri,
    ) -> *mut raptor_term;
}
extern "C" {
    pub fn raptor_new_term_from_counted_uri_string(
        world: *mut raptor_world,
        uri_string: *const libc::c_uchar,
        length: usize,
    ) -> *mut raptor_term;
}
extern "C" {
    pub fn raptor_new_term_from_uri_string(
        world: *mut raptor_world,
        uri_string: *const libc::c_uchar,
    ) -> *mut raptor_term;
}
extern "C" {
    pub fn raptor_new_term_from_literal(
        world: *mut raptor_world,
        literal: *const libc::c_uchar,
        datatype: *mut raptor_uri,
        language: *const libc::c_uchar,
    ) -> *mut raptor_term;
}
extern "C" {
    pub fn raptor_new_term_from_counted_literal(
        world: *mut raptor_world,
        literal: *const libc::c_uchar,
        literal_len: usize,
        datatype: *mut raptor_uri,
        language: *const libc::c_uchar,
        language_len: libc::c_uchar,
    ) -> *mut raptor_term;
}
extern "C" {
    pub fn raptor_new_term_from_blank(
        world: *mut raptor_world,
        blank: *const libc::c_uchar,
    ) -> *mut raptor_term;
}
extern "C" {
    pub fn raptor_new_term_from_counted_blank(
        world: *mut raptor_world,
        blank: *const libc::c_uchar,
        length: usize,
    ) -> *mut raptor_term;
}
extern "C" {
    pub fn raptor_new_term_from_counted_string(
        world: *mut raptor_world,
        string: *mut libc::c_uchar,
        length: usize,
    ) -> *mut raptor_term;
}
extern "C" {
    pub fn raptor_term_copy(term: *mut raptor_term) -> *mut raptor_term;
}
extern "C" {
    pub fn raptor_term_compare(t1: *const raptor_term, t2: *const raptor_term) -> libc::c_int;
}
extern "C" {
    pub fn raptor_term_equals(t1: *mut raptor_term, t2: *mut raptor_term) -> libc::c_int;
}
extern "C" {
    pub fn raptor_free_term(term: *mut raptor_term);
}
extern "C" {
    pub fn raptor_term_to_counted_string(
        term: *mut raptor_term,
        len_p: *mut usize,
    ) -> *mut libc::c_uchar;
}
extern "C" {
    pub fn raptor_term_to_string(term: *mut raptor_term) -> *mut libc::c_uchar;
}
extern "C" {
    pub fn raptor_term_escaped_write(
        term: *const raptor_term,
        flags: libc::c_uint,
        iostr: *mut raptor_iostream,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_term_ntriples_write(
        term: *const raptor_term,
        iostr: *mut raptor_iostream,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_uri_turtle_write(
        world: *mut raptor_world,
        iostr: *mut raptor_iostream,
        uri: *mut raptor_uri,
        nstack: *mut raptor_namespace_stack,
        base_uri: *mut raptor_uri,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_term_turtle_write(
        iostr: *mut raptor_iostream,
        term: *mut raptor_term,
        nstack: *mut raptor_namespace_stack,
        base_uri: *mut raptor_uri,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_uri_to_turtle_counted_string(
        world: *mut raptor_world,
        uri: *mut raptor_uri,
        nstack: *mut raptor_namespace_stack,
        base_uri: *mut raptor_uri,
        len_p: *mut usize,
    ) -> *mut libc::c_uchar;
}
extern "C" {
    pub fn raptor_uri_to_turtle_string(
        world: *mut raptor_world,
        uri: *mut raptor_uri,
        nstack: *mut raptor_namespace_stack,
        base_uri: *mut raptor_uri,
    ) -> *mut libc::c_uchar;
}
extern "C" {
    pub fn raptor_term_to_turtle_counted_string(
        term: *mut raptor_term,
        nstack: *mut raptor_namespace_stack,
        base_uri: *mut raptor_uri,
        len_p: *mut usize,
    ) -> *mut libc::c_uchar;
}
extern "C" {
    pub fn raptor_term_to_turtle_string(
        term: *mut raptor_term,
        nstack: *mut raptor_namespace_stack,
        base_uri: *mut raptor_uri,
    ) -> *mut libc::c_uchar;
}
extern "C" {
    pub fn raptor_statement_init(statement: *mut raptor_statement, world: *mut raptor_world);
}
extern "C" {
    pub fn raptor_statement_clear(statement: *mut raptor_statement);
}
extern "C" {
    pub fn raptor_new_statement(world: *mut raptor_world) -> *mut raptor_statement;
}
extern "C" {
    pub fn raptor_new_statement_from_nodes(
        world: *mut raptor_world,
        subject: *mut raptor_term,
        predicate: *mut raptor_term,
        object: *mut raptor_term,
        graph: *mut raptor_term,
    ) -> *mut raptor_statement;
}
extern "C" {
    pub fn raptor_statement_copy(statement: *mut raptor_statement) -> *mut raptor_statement;
}
extern "C" {
    pub fn raptor_free_statement(statement: *mut raptor_statement);
}
extern "C" {
    pub fn raptor_statement_print(
        statement: *const raptor_statement,
        stream: *mut FILE,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_statement_print_as_ntriples(
        statement: *const raptor_statement,
        stream: *mut FILE,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_statement_compare(
        s1: *const raptor_statement,
        s2: *const raptor_statement,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_statement_equals(
        s1: *const raptor_statement,
        s2: *const raptor_statement,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_new_parser(
        world: *mut raptor_world,
        name: *const libc::c_char,
    ) -> *mut raptor_parser;
}
extern "C" {
    pub fn raptor_new_parser_for_content(
        world: *mut raptor_world,
        uri: *mut raptor_uri,
        mime_type: *const libc::c_char,
        buffer: *const libc::c_uchar,
        len: usize,
        identifier: *const libc::c_uchar,
    ) -> *mut raptor_parser;
}
extern "C" {
    pub fn raptor_free_parser(parser: *mut raptor_parser);
}
extern "C" {
    pub fn raptor_parser_set_statement_handler(
        parser: *mut raptor_parser,
        user_data: *mut libc::c_void,
        handler: raptor_statement_handler,
    );
}
extern "C" {
    pub fn raptor_parser_set_graph_mark_handler(
        parser: *mut raptor_parser,
        user_data: *mut libc::c_void,
        handler: raptor_graph_mark_handler,
    );
}
extern "C" {
    pub fn raptor_parser_set_namespace_handler(
        parser: *mut raptor_parser,
        user_data: *mut libc::c_void,
        handler: raptor_namespace_handler,
    );
}
extern "C" {
    pub fn raptor_parser_set_uri_filter(
        parser: *mut raptor_parser,
        filter: raptor_uri_filter_func,
        user_data: *mut libc::c_void,
    );
}
extern "C" {
    pub fn raptor_parser_get_locator(rdf_parser: *mut raptor_parser) -> *mut raptor_locator;
}
extern "C" {
    pub fn raptor_parser_parse_start(
        rdf_parser: *mut raptor_parser,
        uri: *mut raptor_uri,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_parser_parse_chunk(
        rdf_parser: *mut raptor_parser,
        buffer: *const libc::c_uchar,
        len: usize,
        is_end: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_parser_parse_file_stream(
        rdf_parser: *mut raptor_parser,
        stream: *mut FILE,
        filename: *const libc::c_char,
        base_uri: *mut raptor_uri,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_parser_parse_file(
        rdf_parser: *mut raptor_parser,
        uri: *mut raptor_uri,
        base_uri: *mut raptor_uri,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_parser_parse_uri(
        rdf_parser: *mut raptor_parser,
        uri: *mut raptor_uri,
        base_uri: *mut raptor_uri,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_parser_parse_uri_with_connection(
        rdf_parser: *mut raptor_parser,
        uri: *mut raptor_uri,
        base_uri: *mut raptor_uri,
        connection: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_parser_parse_iostream(
        rdf_parser: *mut raptor_parser,
        iostr: *mut raptor_iostream,
        base_uri: *mut raptor_uri,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_parser_parse_abort(rdf_parser: *mut raptor_parser);
}
extern "C" {
    pub fn raptor_parser_get_name(rdf_parser: *mut raptor_parser) -> *const libc::c_char;
}
extern "C" {
    pub fn raptor_parser_get_description(
        rdf_parser: *mut raptor_parser,
    ) -> *const raptor_syntax_description;
}
extern "C" {
    pub fn raptor_parser_set_option(
        parser: *mut raptor_parser,
        option: raptor_option,
        string: *const libc::c_char,
        integer: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_parser_get_option(
        parser: *mut raptor_parser,
        option: raptor_option,
        string_p: *mut *mut libc::c_char,
        integer_p: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_parser_get_accept_header(rdf_parser: *mut raptor_parser) -> *const libc::c_char;
}
extern "C" {
    pub fn raptor_parser_get_world(rdf_parser: *mut raptor_parser) -> *mut raptor_world;
}
extern "C" {
    pub fn raptor_parser_get_graph(rdf_parser: *mut raptor_parser) -> *mut raptor_uri;
}
extern "C" {
    pub fn raptor_locator_print(locator: *mut raptor_locator, stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn raptor_locator_format(
        buffer: *mut libc::c_char,
        length: usize,
        locator: *mut raptor_locator,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_locator_line(locator: *mut raptor_locator) -> libc::c_int;
}
extern "C" {
    pub fn raptor_locator_column(locator: *mut raptor_locator) -> libc::c_int;
}
extern "C" {
    pub fn raptor_locator_byte(locator: *mut raptor_locator) -> libc::c_int;
}
extern "C" {
    pub fn raptor_locator_file(locator: *mut raptor_locator) -> *const libc::c_char;
}
extern "C" {
    pub fn raptor_locator_uri(locator: *mut raptor_locator) -> *const libc::c_char;
}
extern "C" {
    pub fn raptor_new_serializer(
        world: *mut raptor_world,
        name: *const libc::c_char,
    ) -> *mut raptor_serializer;
}
extern "C" {
    pub fn raptor_free_serializer(rdf_serializer: *mut raptor_serializer);
}
extern "C" {
    pub fn raptor_serializer_start_to_iostream(
        rdf_serializer: *mut raptor_serializer,
        uri: *mut raptor_uri,
        iostream: *mut raptor_iostream,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_serializer_start_to_filename(
        rdf_serializer: *mut raptor_serializer,
        filename: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_serializer_start_to_string(
        rdf_serializer: *mut raptor_serializer,
        uri: *mut raptor_uri,
        string_p: *mut *mut libc::c_void,
        length_p: *mut usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_serializer_start_to_file_handle(
        rdf_serializer: *mut raptor_serializer,
        uri: *mut raptor_uri,
        fh: *mut FILE,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_serializer_set_namespace(
        rdf_serializer: *mut raptor_serializer,
        uri: *mut raptor_uri,
        prefix: *const libc::c_uchar,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_serializer_set_namespace_from_namespace(
        rdf_serializer: *mut raptor_serializer,
        nspace: *mut raptor_namespace,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_serializer_serialize_statement(
        rdf_serializer: *mut raptor_serializer,
        statement: *mut raptor_statement,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_serializer_serialize_end(rdf_serializer: *mut raptor_serializer) -> libc::c_int;
}
extern "C" {
    pub fn raptor_serializer_get_iostream(
        serializer: *mut raptor_serializer,
    ) -> *mut raptor_iostream;
}
extern "C" {
    pub fn raptor_serializer_get_locator(
        rdf_serializer: *mut raptor_serializer,
    ) -> *mut raptor_locator;
}
extern "C" {
    pub fn raptor_serializer_flush(rdf_serializer: *mut raptor_serializer) -> libc::c_int;
}
extern "C" {
    pub fn raptor_serializer_get_description(
        rdf_serializer: *mut raptor_serializer,
    ) -> *const raptor_syntax_description;
}
extern "C" {
    pub fn raptor_serializer_set_option(
        serializer: *mut raptor_serializer,
        option: raptor_option,
        string: *const libc::c_char,
        integer: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_serializer_get_option(
        serializer: *mut raptor_serializer,
        option: raptor_option,
        string_p: *mut *mut libc::c_char,
        integer_p: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_serializer_get_world(rdf_serializer: *mut raptor_serializer)
        -> *mut raptor_world;
}
extern "C" {
    pub fn raptor_free_memory(ptr: *mut libc::c_void);
}
extern "C" {
    pub fn raptor_alloc_memory(size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn raptor_calloc_memory(nmemb: usize, size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn raptor_new_uri_from_counted_string(
        world: *mut raptor_world,
        uri_string: *const libc::c_uchar,
        length: usize,
    ) -> *mut raptor_uri;
}
extern "C" {
    pub fn raptor_new_uri(
        world: *mut raptor_world,
        uri_string: *const libc::c_uchar,
    ) -> *mut raptor_uri;
}
extern "C" {
    pub fn raptor_new_uri_from_uri_local_name(
        world: *mut raptor_world,
        uri: *mut raptor_uri,
        local_name: *const libc::c_uchar,
    ) -> *mut raptor_uri;
}
extern "C" {
    pub fn raptor_new_uri_relative_to_base(
        world: *mut raptor_world,
        base_uri: *mut raptor_uri,
        uri_string: *const libc::c_uchar,
    ) -> *mut raptor_uri;
}
extern "C" {
    pub fn raptor_new_uri_relative_to_base_counted(
        world: *mut raptor_world,
        base_uri: *mut raptor_uri,
        uri_string: *const libc::c_uchar,
        uri_len: usize,
    ) -> *mut raptor_uri;
}
extern "C" {
    pub fn raptor_new_uri_from_id(
        world: *mut raptor_world,
        base_uri: *mut raptor_uri,
        id: *const libc::c_uchar,
    ) -> *mut raptor_uri;
}
extern "C" {
    pub fn raptor_new_uri_from_uri_or_file_string(
        world: *mut raptor_world,
        base_uri: *mut raptor_uri,
        uri_or_file_string: *const libc::c_uchar,
    ) -> *mut raptor_uri;
}
extern "C" {
    pub fn raptor_new_uri_for_rdf_concept(
        world: *mut raptor_world,
        name: *const libc::c_uchar,
    ) -> *mut raptor_uri;
}
extern "C" {
    pub fn raptor_new_uri_for_xmlbase(old_uri: *mut raptor_uri) -> *mut raptor_uri;
}
extern "C" {
    pub fn raptor_new_uri_for_retrieval(old_uri: *mut raptor_uri) -> *mut raptor_uri;
}
extern "C" {
    pub fn raptor_free_uri(uri: *mut raptor_uri);
}
extern "C" {
    pub fn raptor_uri_equals(uri1: *mut raptor_uri, uri2: *mut raptor_uri) -> libc::c_int;
}
extern "C" {
    pub fn raptor_uri_compare(uri1: *mut raptor_uri, uri2: *mut raptor_uri) -> libc::c_int;
}
extern "C" {
    pub fn raptor_uri_copy(uri: *mut raptor_uri) -> *mut raptor_uri;
}
extern "C" {
    pub fn raptor_uri_as_string(uri: *mut raptor_uri) -> *mut libc::c_uchar;
}
extern "C" {
    pub fn raptor_uri_as_counted_string(
        uri: *mut raptor_uri,
        len_p: *mut usize,
    ) -> *mut libc::c_uchar;
}
extern "C" {
    pub fn raptor_uri_to_relative_counted_uri_string(
        base_uri: *mut raptor_uri,
        reference_uri: *mut raptor_uri,
        length_p: *mut usize,
    ) -> *mut libc::c_uchar;
}
extern "C" {
    pub fn raptor_uri_to_relative_uri_string(
        base_uri: *mut raptor_uri,
        reference_uri: *mut raptor_uri,
    ) -> *mut libc::c_uchar;
}
extern "C" {
    pub fn raptor_uri_print(uri: *const raptor_uri, stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn raptor_uri_to_counted_string(
        uri: *mut raptor_uri,
        len_p: *mut usize,
    ) -> *mut libc::c_uchar;
}
extern "C" {
    pub fn raptor_uri_to_string(uri: *mut raptor_uri) -> *mut libc::c_uchar;
}
extern "C" {
    pub fn raptor_uri_get_world(uri: *mut raptor_uri) -> *mut raptor_world;
}
extern "C" {
    pub fn raptor_uri_file_exists(uri: *mut raptor_uri) -> libc::c_int;
}
extern "C" {
    pub fn raptor_uri_escaped_write(
        uri: *mut raptor_uri,
        base_uri: *mut raptor_uri,
        flags: libc::c_uint,
        iostr: *mut raptor_iostream,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_xml_escape_string_any(
        world: *mut raptor_world,
        string: *const libc::c_uchar,
        len: usize,
        buffer: *mut libc::c_uchar,
        length: usize,
        quote: libc::c_char,
        xml_version: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_xml_escape_string_any_write(
        string: *const libc::c_uchar,
        len: usize,
        quote: libc::c_char,
        xml_version: libc::c_int,
        iostr: *mut raptor_iostream,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_xml_escape_string(
        world: *mut raptor_world,
        string: *const libc::c_uchar,
        len: usize,
        buffer: *mut libc::c_uchar,
        length: usize,
        quote: libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_xml_escape_string_write(
        string: *const libc::c_uchar,
        len: usize,
        quote: libc::c_char,
        iostr: *mut raptor_iostream,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_xml_name_check(
        string: *const libc::c_uchar,
        length: usize,
        xml_version: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_vsnprintf(
        format: *const libc::c_char,
        arguments: *mut __va_list_tag,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn raptor_vsnprintf2(
        buffer: *mut libc::c_char,
        size: usize,
        format: *const libc::c_char,
        arguments: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_snprintf(
        buffer: *mut libc::c_char,
        size: usize,
        format: *const libc::c_char,
        ...
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_vasprintf(
        ret: *mut *mut libc::c_char,
        format: *const libc::c_char,
        arguments: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_uri_resolve_uri_reference(
        base_uri: *const libc::c_uchar,
        reference_uri: *const libc::c_uchar,
        buffer: *mut libc::c_uchar,
        length: usize,
    ) -> usize;
}
extern "C" {
    pub fn raptor_uri_counted_filename_to_uri_string(
        filename: *const libc::c_char,
        filename_len: usize,
    ) -> *mut libc::c_uchar;
}
extern "C" {
    pub fn raptor_uri_filename_to_uri_string(filename: *const libc::c_char) -> *mut libc::c_uchar;
}
extern "C" {
    pub fn raptor_uri_filename_exists(path: *const libc::c_uchar) -> libc::c_int;
}
extern "C" {
    pub fn raptor_uri_uri_string_to_filename(uri_string: *const libc::c_uchar)
        -> *mut libc::c_char;
}
extern "C" {
    pub fn raptor_uri_uri_string_to_filename_fragment(
        uri_string: *const libc::c_uchar,
        fragment_p: *mut *mut libc::c_uchar,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn raptor_uri_uri_string_is_file_uri(uri_string: *const libc::c_uchar) -> libc::c_int;
}
extern "C" {
    pub fn raptor_stringbuffer_append_uri_escaped_counted_string(
        sb: *mut raptor_stringbuffer,
        string: *const libc::c_char,
        length: usize,
        space_is_plus: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_uri_uri_string_to_counted_filename_fragment(
        uri_string: *const libc::c_uchar,
        len_p: *mut usize,
        fragment_p: *mut *mut libc::c_uchar,
        fragment_len_p: *mut usize,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn raptor_uri_uri_string_is_absolute(uri_string: *const libc::c_uchar) -> libc::c_int;
}
extern "C" {
    pub fn raptor_new_www(world: *mut raptor_world) -> *mut raptor_www;
}
extern "C" {
    pub fn raptor_new_www_with_connection(
        world: *mut raptor_world,
        connection: *mut libc::c_void,
    ) -> *mut raptor_www;
}
extern "C" {
    pub fn raptor_free_www(www: *mut raptor_www);
}
extern "C" {
    pub fn raptor_www_set_ssl_cert_options(
        www: *mut raptor_www,
        cert_filename: *const libc::c_char,
        cert_type: *const libc::c_char,
        cert_passphrase: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_www_set_ssl_verify_options(
        www: *mut raptor_www,
        verify_peer: libc::c_int,
        verify_host: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_www_set_user_agent(www: *mut raptor_www, user_agent: *const libc::c_char);
}
extern "C" {
    pub fn raptor_www_set_proxy(www: *mut raptor_www, proxy: *const libc::c_char);
}
extern "C" {
    pub fn raptor_www_set_http_accept(www: *mut raptor_www, value: *const libc::c_char);
}
extern "C" {
    pub fn raptor_www_set_write_bytes_handler(
        www: *mut raptor_www,
        handler: raptor_www_write_bytes_handler,
        user_data: *mut libc::c_void,
    );
}
extern "C" {
    pub fn raptor_www_set_content_type_handler(
        www: *mut raptor_www,
        handler: raptor_www_content_type_handler,
        user_data: *mut libc::c_void,
    );
}
extern "C" {
    pub fn raptor_www_set_final_uri_handler(
        www: *mut raptor_www,
        handler: raptor_www_final_uri_handler,
        user_data: *mut libc::c_void,
    );
}
extern "C" {
    pub fn raptor_www_set_uri_filter(
        www: *mut raptor_www,
        filter: raptor_uri_filter_func,
        user_data: *mut libc::c_void,
    );
}
extern "C" {
    pub fn raptor_www_set_connection_timeout(www: *mut raptor_www, timeout: libc::c_int);
}
extern "C" {
    pub fn raptor_www_set_http_cache_control(
        www: *mut raptor_www,
        cache_control: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_www_fetch(www: *mut raptor_www, uri: *mut raptor_uri) -> libc::c_int;
}
extern "C" {
    pub fn raptor_www_fetch_to_string(
        www: *mut raptor_www,
        uri: *mut raptor_uri,
        string_p: *mut *mut libc::c_void,
        length_p: *mut usize,
        malloc_handler: raptor_data_malloc_handler,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_www_get_connection(www: *mut raptor_www) -> *mut libc::c_void;
}
extern "C" {
    pub fn raptor_www_abort(www: *mut raptor_www, reason: *const libc::c_char);
}
extern "C" {
    pub fn raptor_www_get_final_uri(www: *mut raptor_www) -> *mut raptor_uri;
}
extern "C" {
    pub fn raptor_new_qname(
        nstack: *mut raptor_namespace_stack,
        name: *const libc::c_uchar,
        value: *const libc::c_uchar,
    ) -> *mut raptor_qname;
}
extern "C" {
    pub fn raptor_new_qname_from_namespace_local_name(
        world: *mut raptor_world,
        ns: *mut raptor_namespace,
        local_name: *const libc::c_uchar,
        value: *const libc::c_uchar,
    ) -> *mut raptor_qname;
}
extern "C" {
    pub fn raptor_qname_copy(qname: *mut raptor_qname) -> *mut raptor_qname;
}
extern "C" {
    pub fn raptor_free_qname(name: *mut raptor_qname);
}
extern "C" {
    pub fn raptor_qname_equal(name1: *mut raptor_qname, name2: *mut raptor_qname) -> libc::c_int;
}
extern "C" {
    pub fn raptor_qname_to_counted_name(
        qname: *mut raptor_qname,
        length_p: *mut usize,
    ) -> *mut libc::c_uchar;
}
extern "C" {
    pub fn raptor_qname_get_namespace(name: *mut raptor_qname) -> *const raptor_namespace;
}
extern "C" {
    pub fn raptor_qname_get_local_name(name: *mut raptor_qname) -> *const libc::c_uchar;
}
extern "C" {
    pub fn raptor_qname_get_value(name: *mut raptor_qname) -> *const libc::c_uchar;
}
extern "C" {
    pub fn raptor_qname_get_counted_value(
        name: *mut raptor_qname,
        length_p: *mut usize,
    ) -> *const libc::c_uchar;
}
extern "C" {
    pub fn raptor_qname_write(qname: *mut raptor_qname, iostr: *mut raptor_iostream)
        -> libc::c_int;
}
extern "C" {
    pub fn raptor_qname_string_to_uri(
        nstack: *mut raptor_namespace_stack,
        name: *const libc::c_uchar,
        name_len: usize,
    ) -> *mut raptor_uri;
}
extern "C" {
    pub fn raptor_qname_format_as_xml(
        qname: *const raptor_qname,
        length_p: *mut usize,
    ) -> *mut libc::c_uchar;
}
extern "C" {
    pub fn raptor_new_namespace_from_uri(
        nstack: *mut raptor_namespace_stack,
        prefix: *const libc::c_uchar,
        ns_uri: *mut raptor_uri,
        depth: libc::c_int,
    ) -> *mut raptor_namespace;
}
extern "C" {
    pub fn raptor_new_namespaces(
        world: *mut raptor_world,
        defaults: libc::c_int,
    ) -> *mut raptor_namespace_stack;
}
extern "C" {
    pub fn raptor_namespaces_init(
        world: *mut raptor_world,
        nstack: *mut raptor_namespace_stack,
        defaults: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_namespaces_clear(nstack: *mut raptor_namespace_stack);
}
extern "C" {
    pub fn raptor_free_namespaces(nstack: *mut raptor_namespace_stack);
}
extern "C" {
    pub fn raptor_namespaces_start_namespace(
        nstack: *mut raptor_namespace_stack,
        nspace: *mut raptor_namespace,
    );
}
extern "C" {
    pub fn raptor_namespaces_start_namespace_full(
        nstack: *mut raptor_namespace_stack,
        prefix: *const libc::c_uchar,
        ns_uri_string: *const libc::c_uchar,
        depth: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_namespaces_end_for_depth(nstack: *mut raptor_namespace_stack, depth: libc::c_int);
}
extern "C" {
    pub fn raptor_namespaces_get_default_namespace(
        nstack: *mut raptor_namespace_stack,
    ) -> *mut raptor_namespace;
}
extern "C" {
    pub fn raptor_namespaces_find_namespace(
        nstack: *mut raptor_namespace_stack,
        prefix: *const libc::c_uchar,
        prefix_length: libc::c_int,
    ) -> *mut raptor_namespace;
}
extern "C" {
    pub fn raptor_namespaces_find_namespace_by_uri(
        nstack: *mut raptor_namespace_stack,
        ns_uri: *mut raptor_uri,
    ) -> *mut raptor_namespace;
}
extern "C" {
    pub fn raptor_namespaces_namespace_in_scope(
        nstack: *mut raptor_namespace_stack,
        nspace: *const raptor_namespace,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_new_qname_from_namespace_uri(
        nstack: *mut raptor_namespace_stack,
        uri: *mut raptor_uri,
        xml_version: libc::c_int,
    ) -> *mut raptor_qname;
}
extern "C" {
    pub fn raptor_new_namespace(
        nstack: *mut raptor_namespace_stack,
        prefix: *const libc::c_uchar,
        ns_uri_string: *const libc::c_uchar,
        depth: libc::c_int,
    ) -> *mut raptor_namespace;
}
extern "C" {
    pub fn raptor_free_namespace(ns: *mut raptor_namespace);
}
extern "C" {
    pub fn raptor_namespace_stack_start_namespace(
        nstack: *mut raptor_namespace_stack,
        ns: *mut raptor_namespace,
        new_depth: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_namespace_get_uri(ns: *const raptor_namespace) -> *mut raptor_uri;
}
extern "C" {
    pub fn raptor_namespace_get_prefix(ns: *const raptor_namespace) -> *const libc::c_uchar;
}
extern "C" {
    pub fn raptor_namespace_get_counted_prefix(
        ns: *const raptor_namespace,
        length_p: *mut usize,
    ) -> *const libc::c_uchar;
}
extern "C" {
    pub fn raptor_namespace_format_as_xml(
        ns: *const raptor_namespace,
        length_p: *mut usize,
    ) -> *mut libc::c_uchar;
}
extern "C" {
    pub fn raptor_namespace_write(
        ns: *mut raptor_namespace,
        iostr: *mut raptor_iostream,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_xml_namespace_string_parse(
        string: *const libc::c_uchar,
        prefix: *mut *mut libc::c_uchar,
        uri_string: *mut *mut libc::c_uchar,
    ) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raptor_sequence_s {
    _unused: [u8; 0],
}
/// raptor_sequence:
///
/// Raptor sequence class
pub type raptor_sequence = raptor_sequence_s;
extern "C" {
    pub fn raptor_new_sequence(
        free_handler: raptor_data_free_handler,
        print_handler: raptor_data_print_handler,
    ) -> *mut raptor_sequence;
}
extern "C" {
    pub fn raptor_new_sequence_with_context(
        free_handler: raptor_data_context_free_handler,
        print_handler: raptor_data_context_print_handler,
        handler_context: *mut libc::c_void,
    ) -> *mut raptor_sequence;
}
extern "C" {
    pub fn raptor_free_sequence(seq: *mut raptor_sequence);
}
extern "C" {
    pub fn raptor_sequence_size(seq: *mut raptor_sequence) -> libc::c_int;
}
extern "C" {
    pub fn raptor_sequence_set_at(
        seq: *mut raptor_sequence,
        idx: libc::c_int,
        data: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_sequence_push(seq: *mut raptor_sequence, data: *mut libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn raptor_sequence_shift(seq: *mut raptor_sequence, data: *mut libc::c_void)
        -> libc::c_int;
}
extern "C" {
    pub fn raptor_sequence_get_at(seq: *mut raptor_sequence, idx: libc::c_int)
        -> *mut libc::c_void;
}
extern "C" {
    pub fn raptor_sequence_pop(seq: *mut raptor_sequence) -> *mut libc::c_void;
}
extern "C" {
    pub fn raptor_sequence_unshift(seq: *mut raptor_sequence) -> *mut libc::c_void;
}
extern "C" {
    pub fn raptor_sequence_delete_at(
        seq: *mut raptor_sequence,
        idx: libc::c_int,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn raptor_sequence_sort(seq: *mut raptor_sequence, compare: raptor_data_compare_handler);
}
extern "C" {
    pub fn raptor_sequence_sort_r(
        seq: *mut raptor_sequence,
        compare: raptor_data_compare_arg_handler,
        user_data: *mut libc::c_void,
    );
}
extern "C" {
    pub fn raptor_sequence_swap(
        seq: *mut raptor_sequence,
        i: libc::c_int,
        j: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_sequence_reverse(
        seq: *mut raptor_sequence,
        start_index: libc::c_int,
        length: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_sequence_next_permutation(
        seq: *mut raptor_sequence,
        compare: raptor_data_compare_handler,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_sequence_print(seq: *mut raptor_sequence, fh: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn raptor_sequence_join(
        dest: *mut raptor_sequence,
        src: *mut raptor_sequence,
    ) -> libc::c_int;
}
/// raptor_unichar:
///
/// raptor Unicode codepoint
pub type raptor_unichar = libc::c_ulong;
extern "C" {
    pub fn raptor_unicode_utf8_string_put_char(
        c: raptor_unichar,
        output: *mut libc::c_uchar,
        length: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_unicode_utf8_string_get_char(
        input: *const libc::c_uchar,
        length: usize,
        output: *mut raptor_unichar,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_unicode_is_xml11_namestartchar(c: raptor_unichar) -> libc::c_int;
}
extern "C" {
    pub fn raptor_unicode_is_xml10_namestartchar(c: raptor_unichar) -> libc::c_int;
}
extern "C" {
    pub fn raptor_unicode_is_xml11_namechar(c: raptor_unichar) -> libc::c_int;
}
extern "C" {
    pub fn raptor_unicode_is_xml10_namechar(c: raptor_unichar) -> libc::c_int;
}
extern "C" {
    pub fn raptor_unicode_check_utf8_string(
        string: *const libc::c_uchar,
        length: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_unicode_utf8_strlen(string: *const libc::c_uchar, length: usize) -> libc::c_int;
}
extern "C" {
    pub fn raptor_unicode_utf8_substr(
        dest: *mut libc::c_uchar,
        dest_length_p: *mut usize,
        src: *const libc::c_uchar,
        src_length: usize,
        startingLoc: libc::c_int,
        length: libc::c_int,
    ) -> usize;
}
extern "C" {
    pub fn raptor_new_stringbuffer() -> *mut raptor_stringbuffer;
}
extern "C" {
    pub fn raptor_free_stringbuffer(stringbuffer: *mut raptor_stringbuffer);
}
extern "C" {
    pub fn raptor_stringbuffer_append_counted_string(
        stringbuffer: *mut raptor_stringbuffer,
        string: *const libc::c_uchar,
        length: usize,
        do_copy: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_stringbuffer_append_string(
        stringbuffer: *mut raptor_stringbuffer,
        string: *const libc::c_uchar,
        do_copy: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_stringbuffer_append_decimal(
        stringbuffer: *mut raptor_stringbuffer,
        integer: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_stringbuffer_append_hexadecimal(
        stringbuffer: *mut raptor_stringbuffer,
        hex: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_stringbuffer_append_stringbuffer(
        stringbuffer: *mut raptor_stringbuffer,
        append: *mut raptor_stringbuffer,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_stringbuffer_prepend_counted_string(
        stringbuffer: *mut raptor_stringbuffer,
        string: *const libc::c_uchar,
        length: usize,
        do_copy: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_stringbuffer_prepend_string(
        stringbuffer: *mut raptor_stringbuffer,
        string: *const libc::c_uchar,
        do_copy: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_stringbuffer_as_string(
        stringbuffer: *mut raptor_stringbuffer,
    ) -> *mut libc::c_uchar;
}
extern "C" {
    pub fn raptor_stringbuffer_length(stringbuffer: *mut raptor_stringbuffer) -> usize;
}
extern "C" {
    pub fn raptor_stringbuffer_copy_to_string(
        stringbuffer: *mut raptor_stringbuffer,
        string: *mut libc::c_uchar,
        length: usize,
    ) -> libc::c_int;
}
/// raptor_iostream_init_func:
/// @context: stream context data
///
/// Handler function for #raptor_iostream initialising.
///
/// Return value: non-0 on failure.
pub type raptor_iostream_init_func =
    ::std::option::Option<unsafe extern "C" fn(context: *mut libc::c_void) -> libc::c_int>;
/// raptor_iostream_finish_func:
/// @context: stream context data
///
/// Handler function for #raptor_iostream terminating.
///
pub type raptor_iostream_finish_func =
    ::std::option::Option<unsafe extern "C" fn(context: *mut libc::c_void)>;
/// raptor_iostream_write_byte_func
/// @context: stream context data
/// @byte: byte to write
///
/// Handler function for implementing raptor_iostream_write_byte().
///
/// Return value: non-0 on failure.
pub type raptor_iostream_write_byte_func = ::std::option::Option<
    unsafe extern "C" fn(context: *mut libc::c_void, byte: libc::c_int) -> libc::c_int,
>;
/// raptor_iostream_write_bytes_func:
/// @context: stream context data
/// @ptr: pointer to bytes to write
/// @size: size of item
/// @nmemb: number of items
///
/// Handler function for implementing raptor_iostream_write_bytes().
///
/// Return value: non-0 on failure.
pub type raptor_iostream_write_bytes_func = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut libc::c_void,
        ptr: *const libc::c_void,
        size: usize,
        nmemb: usize,
    ) -> libc::c_int,
>;
/// raptor_iostream_write_end_func:
/// @context: stream context data
///
/// Handler function for implementing raptor_iostream_write_end().
///
/// Return value: non-0 on failure.
pub type raptor_iostream_write_end_func =
    ::std::option::Option<unsafe extern "C" fn(context: *mut libc::c_void) -> libc::c_int>;
/// raptor_iostream_read_bytes_func:
/// @context: stream context data
/// @ptr: pointer to buffer to read into
/// @size: size of buffer
/// @nmemb: number of items
///
/// Handler function for implementing raptor_iostream_read_bytes().
///
/// Return value: number of items read, 0 or < @size on EOF, <0 on failure
pub type raptor_iostream_read_bytes_func = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut libc::c_void,
        ptr: *mut libc::c_void,
        size: usize,
        nmemb: usize,
    ) -> libc::c_int,
>;
/// raptor_iostream_read_eof_func:
/// @context: stream context data
///
/// Handler function for implementing raptor_iostream_read_eof().
///
/// Return value: non-0 if EOF
pub type raptor_iostream_read_eof_func =
    ::std::option::Option<unsafe extern "C" fn(context: *mut libc::c_void) -> libc::c_int>;
/// raptor_iostream_handler:
/// @version: interface version.  Presently 1 or 2.
/// @init:  initialisation handler - optional, called at most once (V1)
/// @finish: finishing handler -  optional, called at most once (V1)
/// @write_byte: write byte handler - required (for writing) (V1)
/// @write_bytes: write bytes handler - required (for writing) (V1)
/// @write_end: write end handler - optional (for writing), called at most once (V1)
/// @read_bytes: read bytes handler - required (for reading) (V2)
/// @read_eof: read EOF handler - required (for reading) (V2)
///
/// I/O stream implementation handler structure.
///
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raptor_iostream_handler {
    pub version: libc::c_int,
    pub init: raptor_iostream_init_func,
    pub finish: raptor_iostream_finish_func,
    pub write_byte: raptor_iostream_write_byte_func,
    pub write_bytes: raptor_iostream_write_bytes_func,
    pub write_end: raptor_iostream_write_end_func,
    pub read_bytes: raptor_iostream_read_bytes_func,
    pub read_eof: raptor_iostream_read_eof_func,
}
#[test]
fn bindgen_test_layout_raptor_iostream_handler() {
    assert_eq!(
        ::std::mem::size_of::<raptor_iostream_handler>(),
        64usize,
        concat!("Size of: ", stringify!(raptor_iostream_handler))
    );
    assert_eq!(
        ::std::mem::align_of::<raptor_iostream_handler>(),
        8usize,
        concat!("Alignment of ", stringify!(raptor_iostream_handler))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raptor_iostream_handler>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_iostream_handler),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raptor_iostream_handler>())).init as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_iostream_handler),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raptor_iostream_handler>())).finish as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_iostream_handler),
            "::",
            stringify!(finish)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<raptor_iostream_handler>())).write_byte as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_iostream_handler),
            "::",
            stringify!(write_byte)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<raptor_iostream_handler>())).write_bytes as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_iostream_handler),
            "::",
            stringify!(write_bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<raptor_iostream_handler>())).write_end as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_iostream_handler),
            "::",
            stringify!(write_end)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<raptor_iostream_handler>())).read_bytes as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_iostream_handler),
            "::",
            stringify!(read_bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<raptor_iostream_handler>())).read_eof as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_iostream_handler),
            "::",
            stringify!(read_eof)
        )
    );
}
extern "C" {
    pub fn raptor_new_iostream_from_handler(
        world: *mut raptor_world,
        user_data: *mut libc::c_void,
        handler: *const raptor_iostream_handler,
    ) -> *mut raptor_iostream;
}
extern "C" {
    pub fn raptor_new_iostream_to_sink(world: *mut raptor_world) -> *mut raptor_iostream;
}
extern "C" {
    pub fn raptor_new_iostream_to_filename(
        world: *mut raptor_world,
        filename: *const libc::c_char,
    ) -> *mut raptor_iostream;
}
extern "C" {
    pub fn raptor_new_iostream_to_file_handle(
        world: *mut raptor_world,
        handle: *mut FILE,
    ) -> *mut raptor_iostream;
}
extern "C" {
    pub fn raptor_new_iostream_to_string(
        world: *mut raptor_world,
        string_p: *mut *mut libc::c_void,
        length_p: *mut usize,
        malloc_handler: raptor_data_malloc_handler,
    ) -> *mut raptor_iostream;
}
extern "C" {
    pub fn raptor_new_iostream_from_sink(world: *mut raptor_world) -> *mut raptor_iostream;
}
extern "C" {
    pub fn raptor_new_iostream_from_filename(
        world: *mut raptor_world,
        filename: *const libc::c_char,
    ) -> *mut raptor_iostream;
}
extern "C" {
    pub fn raptor_new_iostream_from_file_handle(
        world: *mut raptor_world,
        handle: *mut FILE,
    ) -> *mut raptor_iostream;
}
extern "C" {
    pub fn raptor_new_iostream_from_string(
        world: *mut raptor_world,
        string: *mut libc::c_void,
        length: usize,
    ) -> *mut raptor_iostream;
}
extern "C" {
    pub fn raptor_free_iostream(iostr: *mut raptor_iostream);
}
extern "C" {
    pub fn raptor_iostream_write_bytes(
        ptr: *const libc::c_void,
        size: usize,
        nmemb: usize,
        iostr: *mut raptor_iostream,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_iostream_write_byte(
        byte: libc::c_int,
        iostr: *mut raptor_iostream,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_iostream_write_end(iostr: *mut raptor_iostream) -> libc::c_int;
}
extern "C" {
    pub fn raptor_iostream_string_write(
        string: *const libc::c_void,
        iostr: *mut raptor_iostream,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_iostream_counted_string_write(
        string: *const libc::c_void,
        len: usize,
        iostr: *mut raptor_iostream,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_iostream_tell(iostr: *mut raptor_iostream) -> libc::c_ulong;
}
extern "C" {
    pub fn raptor_iostream_decimal_write(
        integer: libc::c_int,
        iostr: *mut raptor_iostream,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_iostream_hexadecimal_write(
        integer: libc::c_uint,
        width: libc::c_int,
        iostr: *mut raptor_iostream,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_stringbuffer_write(
        sb: *mut raptor_stringbuffer,
        iostr: *mut raptor_iostream,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_uri_write(uri: *mut raptor_uri, iostr: *mut raptor_iostream) -> libc::c_int;
}
extern "C" {
    pub fn raptor_iostream_read_bytes(
        ptr: *mut libc::c_void,
        size: usize,
        nmemb: usize,
        iostr: *mut raptor_iostream,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_iostream_read_eof(iostr: *mut raptor_iostream) -> libc::c_int;
}
pub const raptor_escaped_write_bitflags_RAPTOR_ESCAPED_WRITE_BITFLAG_BS_ESCAPES_BF:
    raptor_escaped_write_bitflags = 1;
pub const raptor_escaped_write_bitflags_RAPTOR_ESCAPED_WRITE_BITFLAG_BS_ESCAPES_TNRU:
    raptor_escaped_write_bitflags = 2;
pub const raptor_escaped_write_bitflags_RAPTOR_ESCAPED_WRITE_BITFLAG_UTF8:
    raptor_escaped_write_bitflags = 4;
pub const raptor_escaped_write_bitflags_RAPTOR_ESCAPED_WRITE_BITFLAG_SPARQL_URI_ESCAPES:
    raptor_escaped_write_bitflags = 8;
pub const raptor_escaped_write_bitflags_RAPTOR_ESCAPED_WRITE_NTRIPLES_LITERAL:
    raptor_escaped_write_bitflags = 3;
pub const raptor_escaped_write_bitflags_RAPTOR_ESCAPED_WRITE_NTRIPLES_URI:
    raptor_escaped_write_bitflags = 8;
pub const raptor_escaped_write_bitflags_RAPTOR_ESCAPED_WRITE_SPARQL_LITERAL:
    raptor_escaped_write_bitflags = 4;
pub const raptor_escaped_write_bitflags_RAPTOR_ESCAPED_WRITE_SPARQL_LONG_LITERAL:
    raptor_escaped_write_bitflags = 4;
pub const raptor_escaped_write_bitflags_RAPTOR_ESCAPED_WRITE_SPARQL_URI:
    raptor_escaped_write_bitflags = 12;
pub const raptor_escaped_write_bitflags_RAPTOR_ESCAPED_WRITE_TURTLE_URI:
    raptor_escaped_write_bitflags = 12;
pub const raptor_escaped_write_bitflags_RAPTOR_ESCAPED_WRITE_TURTLE_LITERAL:
    raptor_escaped_write_bitflags = 4;
pub const raptor_escaped_write_bitflags_RAPTOR_ESCAPED_WRITE_TURTLE_LONG_LITERAL:
    raptor_escaped_write_bitflags = 4;
pub const raptor_escaped_write_bitflags_RAPTOR_ESCAPED_WRITE_JSON_LITERAL:
    raptor_escaped_write_bitflags = 3;
/// raptor_escaped_write_bitflags:
/// @RAPTOR_ESCAPED_WRITE_BITFLAG_BS_ESCAPES_BF   : Allow \b \f,
/// @RAPTOR_ESCAPED_WRITE_BITFLAG_BS_ESCAPES_TNRU : ALlow \t \n \r \u
/// @RAPTOR_ESCAPED_WRITE_BITFLAG_UTF8            : Allow UTF-8 for printable U *
/// @RAPTOR_ESCAPED_WRITE_BITFLAG_SPARQL_URI_ESCAPES: Must escape #x00-#x20<>\"{}|^` in URIs
/// @RAPTOR_ESCAPED_WRITE_NTRIPLES_LITERAL: N-Triples literal
/// @RAPTOR_ESCAPED_WRITE_NTRIPLES_URI: N-Triples URI
/// @RAPTOR_ESCAPED_WRITE_SPARQL_LITERAL: SPARQL literal: allows raw UTF8 for printable literals
/// @RAPTOR_ESCAPED_WRITE_SPARQL_LONG_LITERAL: SPARQL long literal: no BS-escapes allowed
/// @RAPTOR_ESCAPED_WRITE_SPARQL_URI: SPARQL uri: have to escape certain characters
/// @RAPTOR_ESCAPED_WRITE_TURTLE_URI: Turtle 2013 URIs (like SPARQL)
/// @RAPTOR_ESCAPED_WRITE_TURTLE_LITERAL: Turtle 2013 literals (like SPARQL)
/// @RAPTOR_ESCAPED_WRITE_TURTLE_LONG_LITERAL: Turtle 2013 long literals (like SPARQL)
/// @RAPTOR_ESCAPED_WRITE_JSON_LITERAL: JSON literals: \b \f \t \r \n and \u \U
///
/// Bit flags for raptor_string_escaped_write() and friends.
pub type raptor_escaped_write_bitflags = u32;
extern "C" {
    pub fn raptor_string_ntriples_write(
        string: *const libc::c_uchar,
        len: usize,
        delim: libc::c_char,
        iostr: *mut raptor_iostream,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_bnodeid_ntriples_write(
        bnodeid: *const libc::c_uchar,
        len: usize,
        iostr: *mut raptor_iostream,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_string_python_write(
        string: *const libc::c_uchar,
        len: usize,
        delim: libc::c_char,
        mode: libc::c_uint,
        iostr: *mut raptor_iostream,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_statement_ntriples_write(
        statement: *const raptor_statement,
        iostr: *mut raptor_iostream,
        write_graph_term: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_string_escaped_write(
        string: *const libc::c_uchar,
        len: usize,
        delim: libc::c_char,
        flags: libc::c_uint,
        iostr: *mut raptor_iostream,
    ) -> libc::c_int;
}
pub const raptor_option_value_type_RAPTOR_OPTION_VALUE_TYPE_BOOL: raptor_option_value_type = 0;
pub const raptor_option_value_type_RAPTOR_OPTION_VALUE_TYPE_INT: raptor_option_value_type = 1;
pub const raptor_option_value_type_RAPTOR_OPTION_VALUE_TYPE_STRING: raptor_option_value_type = 2;
pub const raptor_option_value_type_RAPTOR_OPTION_VALUE_TYPE_URI: raptor_option_value_type = 3;
pub const raptor_option_value_type_RAPTOR_OPTION_VALUE_TYPE_LAST: raptor_option_value_type = 3;
/// raptor_option_value_type:
/// @RAPTOR_OPTION_VALUE_TYPE_BOOL: Boolean integer value. Non-0 is true
/// @RAPTOR_OPTION_VALUE_TYPE_INT: Decimal integer value
/// @RAPTOR_OPTION_VALUE_TYPE_STRING: String value
/// @RAPTOR_OPTION_VALUE_TYPE_URI: URI String value.
/// @RAPTOR_OPTION_VALUE_TYPE_LAST: internal
///
/// Option value types.
pub type raptor_option_value_type = u32;
/// raptor_option_description:
/// @domain: domain ID
/// @option: option ID
/// @value_type: data type of option value
/// @name: short name for option
/// @name_len: length of @name
/// @label: description of option
/// @uri: URI identifying option
///
/// Description of an option for a domain.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raptor_option_description {
    pub domain: raptor_domain,
    pub option: raptor_option,
    pub value_type: raptor_option_value_type,
    pub name: *const libc::c_char,
    pub name_len: usize,
    pub label: *const libc::c_char,
    pub uri: *mut raptor_uri,
}
#[test]
fn bindgen_test_layout_raptor_option_description() {
    assert_eq!(
        ::std::mem::size_of::<raptor_option_description>(),
        48usize,
        concat!("Size of: ", stringify!(raptor_option_description))
    );
    assert_eq!(
        ::std::mem::align_of::<raptor_option_description>(),
        8usize,
        concat!("Alignment of ", stringify!(raptor_option_description))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<raptor_option_description>())).domain as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_option_description),
            "::",
            stringify!(domain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<raptor_option_description>())).option as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_option_description),
            "::",
            stringify!(option)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<raptor_option_description>())).value_type as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_option_description),
            "::",
            stringify!(value_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raptor_option_description>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_option_description),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<raptor_option_description>())).name_len as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_option_description),
            "::",
            stringify!(name_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raptor_option_description>())).label as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_option_description),
            "::",
            stringify!(label)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raptor_option_description>())).uri as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(raptor_option_description),
            "::",
            stringify!(uri)
        )
    );
}
extern "C" {
    pub fn raptor_option_get_count() -> libc::c_uint;
}
extern "C" {
    pub fn raptor_option_get_value_type_label(
        type_: raptor_option_value_type,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn raptor_free_option_description(option_description: *mut raptor_option_description);
}
extern "C" {
    pub fn raptor_world_get_option_description(
        world: *mut raptor_world,
        domain: raptor_domain,
        option: raptor_option,
    ) -> *mut raptor_option_description;
}
extern "C" {
    pub fn raptor_new_xml_element(
        name: *mut raptor_qname,
        xml_language: *const libc::c_uchar,
        xml_base: *mut raptor_uri,
    ) -> *mut raptor_xml_element;
}
extern "C" {
    pub fn raptor_new_xml_element_from_namespace_local_name(
        ns: *mut raptor_namespace,
        name: *const libc::c_uchar,
        xml_language: *const libc::c_uchar,
        xml_base: *mut raptor_uri,
    ) -> *mut raptor_xml_element;
}
extern "C" {
    pub fn raptor_free_xml_element(element: *mut raptor_xml_element);
}
extern "C" {
    pub fn raptor_xml_element_get_name(xml_element: *mut raptor_xml_element) -> *mut raptor_qname;
}
extern "C" {
    pub fn raptor_xml_element_set_attributes(
        xml_element: *mut raptor_xml_element,
        attributes: *mut *mut raptor_qname,
        count: libc::c_int,
    );
}
extern "C" {
    pub fn raptor_xml_element_get_attributes(
        xml_element: *mut raptor_xml_element,
    ) -> *mut *mut raptor_qname;
}
extern "C" {
    pub fn raptor_xml_element_get_attributes_count(
        xml_element: *mut raptor_xml_element,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_xml_element_declare_namespace(
        xml_element: *mut raptor_xml_element,
        nspace: *mut raptor_namespace,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_xml_element_write(
        element: *mut raptor_xml_element,
        nstack: *mut raptor_namespace_stack,
        is_empty: libc::c_int,
        is_end: libc::c_int,
        depth: libc::c_int,
        iostr: *mut raptor_iostream,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_xml_element_is_empty(xml_element: *mut raptor_xml_element) -> libc::c_int;
}
extern "C" {
    pub fn raptor_xml_element_get_language(
        xml_element: *mut raptor_xml_element,
    ) -> *const libc::c_uchar;
}
extern "C" {
    pub fn raptor_new_xml_writer(
        world: *mut raptor_world,
        nstack: *mut raptor_namespace_stack,
        iostr: *mut raptor_iostream,
    ) -> *mut raptor_xml_writer;
}
extern "C" {
    pub fn raptor_free_xml_writer(xml_writer: *mut raptor_xml_writer);
}
extern "C" {
    pub fn raptor_xml_writer_empty_element(
        xml_writer: *mut raptor_xml_writer,
        element: *mut raptor_xml_element,
    );
}
extern "C" {
    pub fn raptor_xml_writer_start_element(
        xml_writer: *mut raptor_xml_writer,
        element: *mut raptor_xml_element,
    );
}
extern "C" {
    pub fn raptor_xml_writer_end_element(
        xml_writer: *mut raptor_xml_writer,
        element: *mut raptor_xml_element,
    );
}
extern "C" {
    pub fn raptor_xml_writer_newline(xml_writer: *mut raptor_xml_writer);
}
extern "C" {
    pub fn raptor_xml_writer_cdata(xml_writer: *mut raptor_xml_writer, s: *const libc::c_uchar);
}
extern "C" {
    pub fn raptor_xml_writer_cdata_counted(
        xml_writer: *mut raptor_xml_writer,
        s: *const libc::c_uchar,
        len: libc::c_uint,
    );
}
extern "C" {
    pub fn raptor_xml_writer_raw(xml_writer: *mut raptor_xml_writer, s: *const libc::c_uchar);
}
extern "C" {
    pub fn raptor_xml_writer_raw_counted(
        xml_writer: *mut raptor_xml_writer,
        s: *const libc::c_uchar,
        len: libc::c_uint,
    );
}
extern "C" {
    pub fn raptor_xml_writer_comment(xml_writer: *mut raptor_xml_writer, s: *const libc::c_uchar);
}
extern "C" {
    pub fn raptor_xml_writer_comment_counted(
        xml_writer: *mut raptor_xml_writer,
        s: *const libc::c_uchar,
        len: libc::c_uint,
    );
}
extern "C" {
    pub fn raptor_xml_writer_flush(xml_writer: *mut raptor_xml_writer);
}
extern "C" {
    pub fn raptor_xml_writer_set_option(
        xml_writer: *mut raptor_xml_writer,
        option: raptor_option,
        string: *mut libc::c_char,
        integer: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_xml_writer_get_option(
        xml_writer: *mut raptor_xml_writer,
        option: raptor_option,
        string_p: *mut *mut libc::c_char,
        integer_p: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_xml_writer_get_depth(xml_writer: *mut raptor_xml_writer) -> libc::c_int;
}
/// raptor_sax2_start_element_handler:
/// @user_data: user data
/// @xml_element: XML element
///
/// SAX2 start element handler
pub type raptor_sax2_start_element_handler = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut libc::c_void, xml_element: *mut raptor_xml_element),
>;
/// raptor_sax2_end_element_handler:
/// @user_data: user data
/// @xml_element: XML element
///
/// SAX2 end element handler
pub type raptor_sax2_end_element_handler = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut libc::c_void, xml_element: *mut raptor_xml_element),
>;
/// raptor_sax2_characters_handler:
/// @user_data: user data
/// @xml_element: XML element
/// @s: string
/// @len: string len
///
/// SAX2 characters handler
pub type raptor_sax2_characters_handler = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut libc::c_void,
        xml_element: *mut raptor_xml_element,
        s: *const libc::c_uchar,
        len: libc::c_int,
    ),
>;
/// raptor_sax2_cdata_handler:
/// @user_data: user data
/// @xml_element: XML element
/// @s: string
/// @len: string len
///
/// SAX2 CDATA section handler
pub type raptor_sax2_cdata_handler = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut libc::c_void,
        xml_element: *mut raptor_xml_element,
        s: *const libc::c_uchar,
        len: libc::c_int,
    ),
>;
/// raptor_sax2_comment_handler:
/// @user_data: user data
/// @xml_element: XML element
/// @s: string
///
/// SAX2 XML comment handler
pub type raptor_sax2_comment_handler = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut libc::c_void,
        xml_element: *mut raptor_xml_element,
        s: *const libc::c_uchar,
    ),
>;
/// raptor_sax2_unparsed_entity_decl_handler:
/// @user_data: user data
/// @entityName: entity name
/// @base: base URI
/// @systemId: system ID
/// @publicId: public ID
/// @notationName: notation name
///
/// SAX2 unparsed entity (NDATA) handler
pub type raptor_sax2_unparsed_entity_decl_handler = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut libc::c_void,
        entityName: *const libc::c_uchar,
        base: *const libc::c_uchar,
        systemId: *const libc::c_uchar,
        publicId: *const libc::c_uchar,
        notationName: *const libc::c_uchar,
    ),
>;
/// raptor_sax2_external_entity_ref_handler:
/// @user_data: user data
/// @context: context
/// @base: base URI
/// @systemId: system ID
/// @publicId: public ID
///
/// SAX2 external entity reference handler
///
/// Return value: 0 if processing should not continue because of a
/// fatal error in the handling of the external entity.
pub type raptor_sax2_external_entity_ref_handler = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut libc::c_void,
        context: *const libc::c_uchar,
        base: *const libc::c_uchar,
        systemId: *const libc::c_uchar,
        publicId: *const libc::c_uchar,
    ) -> libc::c_int,
>;
extern "C" {
    pub fn raptor_new_sax2(
        world: *mut raptor_world,
        locator: *mut raptor_locator,
        user_data: *mut libc::c_void,
    ) -> *mut raptor_sax2;
}
extern "C" {
    pub fn raptor_free_sax2(sax2: *mut raptor_sax2);
}
extern "C" {
    pub fn raptor_sax2_set_start_element_handler(
        sax2: *mut raptor_sax2,
        handler: raptor_sax2_start_element_handler,
    );
}
extern "C" {
    pub fn raptor_sax2_set_end_element_handler(
        sax2: *mut raptor_sax2,
        handler: raptor_sax2_end_element_handler,
    );
}
extern "C" {
    pub fn raptor_sax2_set_characters_handler(
        sax2: *mut raptor_sax2,
        handler: raptor_sax2_characters_handler,
    );
}
extern "C" {
    pub fn raptor_sax2_set_cdata_handler(
        sax2: *mut raptor_sax2,
        handler: raptor_sax2_cdata_handler,
    );
}
extern "C" {
    pub fn raptor_sax2_set_comment_handler(
        sax2: *mut raptor_sax2,
        handler: raptor_sax2_comment_handler,
    );
}
extern "C" {
    pub fn raptor_sax2_set_unparsed_entity_decl_handler(
        sax2: *mut raptor_sax2,
        handler: raptor_sax2_unparsed_entity_decl_handler,
    );
}
extern "C" {
    pub fn raptor_sax2_set_external_entity_ref_handler(
        sax2: *mut raptor_sax2,
        handler: raptor_sax2_external_entity_ref_handler,
    );
}
extern "C" {
    pub fn raptor_sax2_set_namespace_handler(
        sax2: *mut raptor_sax2,
        handler: raptor_namespace_handler,
    );
}
extern "C" {
    pub fn raptor_sax2_set_uri_filter(
        sax2: *mut raptor_sax2,
        filter: raptor_uri_filter_func,
        user_data: *mut libc::c_void,
    );
}
extern "C" {
    pub fn raptor_sax2_parse_start(sax2: *mut raptor_sax2, base_uri: *mut raptor_uri);
}
extern "C" {
    pub fn raptor_sax2_parse_chunk(
        sax2: *mut raptor_sax2,
        buffer: *const libc::c_uchar,
        len: usize,
        is_end: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_sax2_inscope_xml_language(sax2: *mut raptor_sax2) -> *const libc::c_uchar;
}
extern "C" {
    pub fn raptor_sax2_inscope_base_uri(sax2: *mut raptor_sax2) -> *mut raptor_uri;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raptor_avltree_s {
    _unused: [u8; 0],
}
/// raptor_avltree:
///
/// AVL Tree
pub type raptor_avltree = raptor_avltree_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raptor_avltree_iterator_s {
    _unused: [u8; 0],
}
/// raptor_avltree_iterator:
///
/// AVL Tree Iterator as created by raptor_new_avltree_iterator()
pub type raptor_avltree_iterator = raptor_avltree_iterator_s;
/// raptor_avltree_visit_handler:
/// @depth: depth of object in tree
/// @data: data object being visited
/// @user_data: user data arg to raptor_avltree_visit()
///
/// AVL Tree visitor function as given to raptor_avltree_visit()
///
/// Return value: non-0 to terminate visit early.
pub type raptor_avltree_visit_handler = ::std::option::Option<
    unsafe extern "C" fn(depth: libc::c_int, data: *mut libc::c_void, user_data: *mut libc::c_void)
        -> libc::c_int,
>;
pub const raptor_avltree_bitflags_RAPTOR_AVLTREE_FLAG_REPLACE_DUPLICATES: raptor_avltree_bitflags =
    1;
/// raptor_avltree_bitflags:
/// @RAPTOR_AVLTREE_FLAG_REPLACE_DUPLICATES: If set raptor_avltree_add() will replace any duplicate items. If not set, raptor_avltree_add() will not replace them and will return status >0 when adding a duplicate. (Default is not set)
///
/// Bit flags for AVL Tree class constructor raptor_new_avltree()
pub type raptor_avltree_bitflags = u32;
extern "C" {
    pub fn raptor_new_avltree(
        compare_handler: raptor_data_compare_handler,
        free_handler: raptor_data_free_handler,
        flags: libc::c_uint,
    ) -> *mut raptor_avltree;
}
extern "C" {
    pub fn raptor_free_avltree(tree: *mut raptor_avltree);
}
extern "C" {
    pub fn raptor_avltree_add(tree: *mut raptor_avltree, p_data: *mut libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn raptor_avltree_remove(
        tree: *mut raptor_avltree,
        p_data: *mut libc::c_void,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn raptor_avltree_delete(
        tree: *mut raptor_avltree,
        p_data: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_avltree_search(
        tree: *mut raptor_avltree,
        p_data: *const libc::c_void,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn raptor_avltree_visit(
        tree: *mut raptor_avltree,
        visit_handler: raptor_avltree_visit_handler,
        user_data: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn raptor_avltree_size(tree: *mut raptor_avltree) -> libc::c_int;
}
extern "C" {
    pub fn raptor_avltree_set_print_handler(
        tree: *mut raptor_avltree,
        print_handler: raptor_data_print_handler,
    );
}
extern "C" {
    pub fn raptor_avltree_print(tree: *mut raptor_avltree, stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn raptor_new_avltree_iterator(
        tree: *mut raptor_avltree,
        range: *mut libc::c_void,
        range_free_handler: raptor_data_free_handler,
        direction: libc::c_int,
    ) -> *mut raptor_avltree_iterator;
}
extern "C" {
    pub fn raptor_free_avltree_iterator(iterator: *mut raptor_avltree_iterator);
}
extern "C" {
    pub fn raptor_avltree_iterator_is_end(iterator: *mut raptor_avltree_iterator) -> libc::c_int;
}
extern "C" {
    pub fn raptor_avltree_iterator_next(iterator: *mut raptor_avltree_iterator) -> libc::c_int;
}
extern "C" {
    pub fn raptor_avltree_iterator_get(iterator: *mut raptor_avltree_iterator)
        -> *mut libc::c_void;
}
extern "C" {
    pub fn raptor_sort_r(
        base: *mut libc::c_void,
        nel: usize,
        width: usize,
        compar: raptor_data_compare_arg_handler,
        user_data: *mut libc::c_void,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub fds_bits: [__int32_t; 32usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        4usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __darwin_time_t,
    pub tv_nsec: libc::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __darwin_time_t,
    pub tv_usec: __darwin_suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval64 {
    pub tv_sec: __int64_t,
    pub tv_usec: __int64_t,
}
#[test]
fn bindgen_test_layout_timeval64() {
    assert_eq!(
        ::std::mem::size_of::<timeval64>(),
        16usize,
        concat!("Size of: ", stringify!(timeval64))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval64>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval64>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval64),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval64>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval64),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type time_t = __darwin_time_t;
pub type suseconds_t = __darwin_suseconds_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[test]
fn bindgen_test_layout_itimerval() {
    assert_eq!(
        ::std::mem::size_of::<itimerval>(),
        32usize,
        concat!("Size of: ", stringify!(itimerval))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerval>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerval>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerval>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: libc::c_int,
    pub tz_dsttime: libc::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    assert_eq!(
        ::std::mem::size_of::<timezone>(),
        8usize,
        concat!("Size of: ", stringify!(timezone))
    );
    assert_eq!(
        ::std::mem::align_of::<timezone>(),
        4usize,
        concat!("Alignment of ", stringify!(timezone))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timezone>())).tz_minuteswest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_minuteswest)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timezone>())).tz_dsttime as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_dsttime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clockinfo {
    pub hz: libc::c_int,
    pub tick: libc::c_int,
    pub tickadj: libc::c_int,
    pub stathz: libc::c_int,
    pub profhz: libc::c_int,
}
#[test]
fn bindgen_test_layout_clockinfo() {
    assert_eq!(
        ::std::mem::size_of::<clockinfo>(),
        20usize,
        concat!("Size of: ", stringify!(clockinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<clockinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(clockinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clockinfo>())).hz as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clockinfo),
            "::",
            stringify!(hz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clockinfo>())).tick as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(clockinfo),
            "::",
            stringify!(tick)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clockinfo>())).tickadj as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clockinfo),
            "::",
            stringify!(tickadj)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clockinfo>())).stathz as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(clockinfo),
            "::",
            stringify!(stathz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clockinfo>())).profhz as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(clockinfo),
            "::",
            stringify!(profhz)
        )
    );
}
pub type clock_t = __darwin_clock_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: libc::c_int,
    pub tm_min: libc::c_int,
    pub tm_hour: libc::c_int,
    pub tm_mday: libc::c_int,
    pub tm_mon: libc::c_int,
    pub tm_year: libc::c_int,
    pub tm_wday: libc::c_int,
    pub tm_yday: libc::c_int,
    pub tm_isdst: libc::c_int,
    pub tm_gmtoff: libc::c_long,
    pub tm_zone: *mut libc::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_gmtoff as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_zone as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
extern "C" {
    pub static mut tzname: [*mut libc::c_char; 0usize];
}
extern "C" {
    pub static mut getdate_err: libc::c_int;
}
extern "C" {
    pub static mut timezone: libc::c_long;
}
extern "C" {
    pub static mut daylight: libc::c_int;
}
extern "C" {
    pub fn asctime(arg1: *const tm) -> *mut libc::c_char;
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn ctime(arg1: *const time_t) -> *mut libc::c_char;
}
extern "C" {
    pub fn difftime(arg1: time_t, arg2: time_t) -> f64;
}
extern "C" {
    pub fn getdate(arg1: *const libc::c_char) -> *mut tm;
}
extern "C" {
    pub fn gmtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn mktime(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        arg1: *mut libc::c_char,
        arg2: usize,
        arg3: *const libc::c_char,
        arg4: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strptime(
        arg1: *const libc::c_char,
        arg2: *const libc::c_char,
        arg3: *mut tm,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn time(arg1: *mut time_t) -> time_t;
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub fn asctime_r(arg1: *const tm, arg2: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn ctime_r(arg1: *const time_t, arg2: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn gmtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn posix2time(arg1: time_t) -> time_t;
}
extern "C" {
    pub fn tzsetwall();
}
extern "C" {
    pub fn time2posix(arg1: time_t) -> time_t;
}
extern "C" {
    pub fn timelocal(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn timegm(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn nanosleep(__rqtp: *const timespec, __rmtp: *mut timespec) -> libc::c_int;
}
pub const clockid_t__CLOCK_REALTIME: clockid_t = 0;
pub const clockid_t__CLOCK_MONOTONIC: clockid_t = 6;
pub const clockid_t__CLOCK_MONOTONIC_RAW: clockid_t = 4;
pub const clockid_t__CLOCK_MONOTONIC_RAW_APPROX: clockid_t = 5;
pub const clockid_t__CLOCK_UPTIME_RAW: clockid_t = 8;
pub const clockid_t__CLOCK_UPTIME_RAW_APPROX: clockid_t = 9;
pub const clockid_t__CLOCK_PROCESS_CPUTIME_ID: clockid_t = 12;
pub const clockid_t__CLOCK_THREAD_CPUTIME_ID: clockid_t = 16;
pub type clockid_t = u32;
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> libc::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> libc::c_int;
}
extern "C" {
    pub fn clock_gettime_nsec_np(__clock_id: clockid_t) -> __uint64_t;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> libc::c_int;
}
extern "C" {
    pub fn adjtime(arg1: *const timeval, arg2: *mut timeval) -> libc::c_int;
}
extern "C" {
    pub fn futimes(arg1: libc::c_int, arg2: *const timeval) -> libc::c_int;
}
extern "C" {
    pub fn lutimes(arg1: *const libc::c_char, arg2: *const timeval) -> libc::c_int;
}
extern "C" {
    pub fn settimeofday(arg1: *const timeval, arg2: *const timezone) -> libc::c_int;
}
extern "C" {
    pub fn getitimer(arg1: libc::c_int, arg2: *mut itimerval) -> libc::c_int;
}
extern "C" {
    pub fn gettimeofday(arg1: *mut timeval, arg2: *mut libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn select(
        arg1: libc::c_int,
        arg2: *mut fd_set,
        arg3: *mut fd_set,
        arg4: *mut fd_set,
        arg5: *mut timeval,
    ) -> libc::c_int;
}
extern "C" {
    pub fn setitimer(
        arg1: libc::c_int,
        arg2: *const itimerval,
        arg3: *mut itimerval,
    ) -> libc::c_int;
}
extern "C" {
    pub fn utimes(arg1: *const libc::c_char, arg2: *const timeval) -> libc::c_int;
}
extern "C" {
    pub static rasqal_short_copyright_string: *const libc::c_char;
}
extern "C" {
    pub static rasqal_copyright_string: *const libc::c_char;
}
extern "C" {
    pub static rasqal_version_string: *const libc::c_char;
}
extern "C" {
    pub static rasqal_version_major: libc::c_uint;
}
extern "C" {
    pub static rasqal_version_minor: libc::c_uint;
}
extern "C" {
    pub static rasqal_version_release: libc::c_uint;
}
extern "C" {
    pub static rasqal_version_decimal: libc::c_uint;
}
extern "C" {
    pub static rasqal_license_string: *const libc::c_char;
}
extern "C" {
    pub static rasqal_home_url_string: *const libc::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rasqal_world_s {
    _unused: [u8; 0],
}
/// rasqal_world:
///
/// Rasqal world class.
pub type rasqal_world = rasqal_world_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rasqal_query_s {
    _unused: [u8; 0],
}
/// rasqal_query:
///
/// Rasqal query class.
pub type rasqal_query = rasqal_query_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rasqal_query_results_s {
    _unused: [u8; 0],
}
/// rasqal_query_results:
///
/// Rasqal query results class.
pub type rasqal_query_results = rasqal_query_results_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rasqal_query_results_formatter_s {
    _unused: [u8; 0],
}
/// rasqal_query_results_formatter:
///
/// Rasqal query results formatter class.
pub type rasqal_query_results_formatter = rasqal_query_results_formatter_s;
pub type rasqal_literal = rasqal_literal_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rasqal_graph_pattern_s {
    _unused: [u8; 0],
}
/// rasqal_graph_pattern:
///
/// Rasqal graph pattern class.
pub type rasqal_graph_pattern = rasqal_graph_pattern_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rasqal_variables_table_s {
    _unused: [u8; 0],
}
/// rasqal_variables_table:
///
/// Rasqal variables table class.
pub type rasqal_variables_table = rasqal_variables_table_s;
pub const rasqal_feature_RASQAL_FEATURE_NO_NET: rasqal_feature = 0;
pub const rasqal_feature_RASQAL_FEATURE_RAND_SEED: rasqal_feature = 1;
pub const rasqal_feature_RASQAL_FEATURE_LAST: rasqal_feature = 1;
/// rasqal_feature:
/// @RASQAL_FEATURE_NO_NET: Deny network requests.
/// @RASQAL_FEATURE_RAND_SEED: Set rand() / rand_r() seed
/// @RASQAL_FEATURE_LAST: Internal.
///
/// Query features.
///
/// None currently defined.
pub type rasqal_feature = u32;
/// rasqal_prefix:
/// @world: rasqal_world object
/// @prefix: short prefix string
/// @uri: URI associated with the prefix.
/// @declared: Internal flag.
/// @depth: Internal flag.
///
/// Namespace (prefix, uri) pair.
///
/// Includes internal flags used for marking when prefixes are
/// declared and at what XML element depth when used in XML formats.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rasqal_prefix {
    pub world: *mut rasqal_world,
    pub prefix: *const libc::c_uchar,
    pub uri: *mut raptor_uri,
    pub declared: libc::c_int,
    pub depth: libc::c_int,
}
#[test]
fn bindgen_test_layout_rasqal_prefix() {
    assert_eq!(
        ::std::mem::size_of::<rasqal_prefix>(),
        32usize,
        concat!("Size of: ", stringify!(rasqal_prefix))
    );
    assert_eq!(
        ::std::mem::align_of::<rasqal_prefix>(),
        8usize,
        concat!("Alignment of ", stringify!(rasqal_prefix))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_prefix>())).world as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_prefix),
            "::",
            stringify!(world)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_prefix>())).prefix as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_prefix),
            "::",
            stringify!(prefix)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_prefix>())).uri as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_prefix),
            "::",
            stringify!(uri)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_prefix>())).declared as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_prefix),
            "::",
            stringify!(declared)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_prefix>())).depth as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_prefix),
            "::",
            stringify!(depth)
        )
    );
}
pub const rasqal_variable_type_RASQAL_VARIABLE_TYPE_UNKNOWN: rasqal_variable_type = 0;
pub const rasqal_variable_type_RASQAL_VARIABLE_TYPE_NORMAL: rasqal_variable_type = 1;
pub const rasqal_variable_type_RASQAL_VARIABLE_TYPE_ANONYMOUS: rasqal_variable_type = 2;
/// rasqal_variable_type:
/// @RASQAL_VARIABLE_TYPE_NORMAL: The regular variable type.
/// @RASQAL_VARIABLE_TYPE_ANONYMOUS: Anonymous variable type.
/// @RASQAL_VARIABLE_TYPE_UNKNOWN: Internal.
///
/// Rasqal variable types.
///
/// ANONYMOUS can be used in queries but cannot be returned in a
/// result.
pub type rasqal_variable_type = u32;
/// rasqal_variable:
/// @vars_table: variables table that owns this variable
/// @name: Variable name.
/// @value: Variable value or NULL if unbound.
/// @offset: Internal.
/// @type: Variable type.
/// @expression: Expression when the variable is a computed SELECT expression
/// @user_data: Pointer to user data associated with a variable.  This is not used by rasqal.
/// @usage: reference count
///
/// Binding between a variable name and a value.
///
/// Includes internal field @offset for recording the offset into the
/// (internal) rasqal_query variables array.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rasqal_variable {
    pub vars_table: *mut rasqal_variables_table,
    pub name: *const libc::c_uchar,
    pub value: *mut rasqal_literal,
    pub offset: libc::c_int,
    pub type_: rasqal_variable_type,
    pub expression: *mut rasqal_expression_s,
    pub user_data: *mut libc::c_void,
    pub usage: libc::c_int,
}
#[test]
fn bindgen_test_layout_rasqal_variable() {
    assert_eq!(
        ::std::mem::size_of::<rasqal_variable>(),
        56usize,
        concat!("Size of: ", stringify!(rasqal_variable))
    );
    assert_eq!(
        ::std::mem::align_of::<rasqal_variable>(),
        8usize,
        concat!("Alignment of ", stringify!(rasqal_variable))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_variable>())).vars_table as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_variable),
            "::",
            stringify!(vars_table)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_variable>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_variable),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_variable>())).value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_variable),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_variable>())).offset as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_variable),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_variable>())).type_ as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_variable),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_variable>())).expression as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_variable),
            "::",
            stringify!(expression)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_variable>())).user_data as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_variable),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_variable>())).usage as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_variable),
            "::",
            stringify!(usage)
        )
    );
}
pub const rasqal_data_graph_flags_RASQAL_DATA_GRAPH_NONE: rasqal_data_graph_flags = 0;
pub const rasqal_data_graph_flags_RASQAL_DATA_GRAPH_NAMED: rasqal_data_graph_flags = 1;
pub const rasqal_data_graph_flags_RASQAL_DATA_GRAPH_BACKGROUND: rasqal_data_graph_flags = 2;
/// rasqal_data_graph_flags:
/// @RASQAL_DATA_GRAPH_NONE: Internal.
/// @RASQAL_DATA_GRAPH_NAMED: Graphs with a source and name.
/// @RASQAL_DATA_GRAPH_BACKGROUND: Graphs with a source only.
///
/// Flags for the type of #rasqal_data_graph.
///
/// These are used by rasqal_new_data_graph_from_uri() and
/// rasqal_new_data_graph_from_iostream().  See #rasqal_data_graph.
pub type rasqal_data_graph_flags = u32;
/// rasqal_data_graph:
/// @world: rasqal_world object
/// @uri: source URI
/// @name_uri: name of graph for %RASQAL_DATA_GRAPH_NAMED
/// @flags: %RASQAL_DATA_GRAPH_NAMED or %RASQAL_DATA_GRAPH_BACKGROUND
/// @format_type: MIME Type of data format at @uri (or NULL)
/// @format_name: Raptor parser Name of data format at @uri (or NULL)
/// @format_uri: URI of data format at @uri (or NULL)
/// @iostr: Raptor iostream for content, overriding @uri if present (or NULL)
/// @base_uri: base URI for reading from iostream
/// @usage: usage count of this object
///
/// A source of RDF data for querying.
///
/// If @iostr is present, the graph can be constructed by parsing the
/// iostream and using @base_uri as a base uri. Otherwise the graph
/// can be constructed from the graph at URI @uri.
///
/// In either case the @name_uri is the graph name as long as @flags
/// is %RASQAL_DATA_GRAPH_NAMED
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rasqal_data_graph {
    pub world: *mut rasqal_world,
    pub uri: *mut raptor_uri,
    pub name_uri: *mut raptor_uri,
    pub flags: libc::c_uint,
    pub format_type: *mut libc::c_char,
    pub format_name: *mut libc::c_char,
    pub format_uri: *mut raptor_uri,
    pub iostr: *mut raptor_iostream,
    pub base_uri: *mut raptor_uri,
    pub usage: libc::c_int,
}
#[test]
fn bindgen_test_layout_rasqal_data_graph() {
    assert_eq!(
        ::std::mem::size_of::<rasqal_data_graph>(),
        80usize,
        concat!("Size of: ", stringify!(rasqal_data_graph))
    );
    assert_eq!(
        ::std::mem::align_of::<rasqal_data_graph>(),
        8usize,
        concat!("Alignment of ", stringify!(rasqal_data_graph))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_data_graph>())).world as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_data_graph),
            "::",
            stringify!(world)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_data_graph>())).uri as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_data_graph),
            "::",
            stringify!(uri)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_data_graph>())).name_uri as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_data_graph),
            "::",
            stringify!(name_uri)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_data_graph>())).flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_data_graph),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_data_graph>())).format_type as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_data_graph),
            "::",
            stringify!(format_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_data_graph>())).format_name as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_data_graph),
            "::",
            stringify!(format_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_data_graph>())).format_uri as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_data_graph),
            "::",
            stringify!(format_uri)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_data_graph>())).iostr as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_data_graph),
            "::",
            stringify!(iostr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_data_graph>())).base_uri as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_data_graph),
            "::",
            stringify!(base_uri)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_data_graph>())).usage as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_data_graph),
            "::",
            stringify!(usage)
        )
    );
}
pub const rasqal_literal_type_RASQAL_LITERAL_UNKNOWN: rasqal_literal_type = 0;
pub const rasqal_literal_type_RASQAL_LITERAL_BLANK: rasqal_literal_type = 1;
pub const rasqal_literal_type_RASQAL_LITERAL_URI: rasqal_literal_type = 2;
pub const rasqal_literal_type_RASQAL_LITERAL_STRING: rasqal_literal_type = 3;
pub const rasqal_literal_type_RASQAL_LITERAL_XSD_STRING: rasqal_literal_type = 4;
pub const rasqal_literal_type_RASQAL_LITERAL_BOOLEAN: rasqal_literal_type = 5;
pub const rasqal_literal_type_RASQAL_LITERAL_INTEGER: rasqal_literal_type = 6;
pub const rasqal_literal_type_RASQAL_LITERAL_FLOAT: rasqal_literal_type = 7;
pub const rasqal_literal_type_RASQAL_LITERAL_DOUBLE: rasqal_literal_type = 8;
pub const rasqal_literal_type_RASQAL_LITERAL_DECIMAL: rasqal_literal_type = 9;
pub const rasqal_literal_type_RASQAL_LITERAL_DATETIME: rasqal_literal_type = 10;
pub const rasqal_literal_type_RASQAL_LITERAL_FIRST_XSD: rasqal_literal_type = 4;
pub const rasqal_literal_type_RASQAL_LITERAL_LAST_XSD: rasqal_literal_type = 10;
pub const rasqal_literal_type_RASQAL_LITERAL_UDT: rasqal_literal_type = 11;
pub const rasqal_literal_type_RASQAL_LITERAL_PATTERN: rasqal_literal_type = 12;
pub const rasqal_literal_type_RASQAL_LITERAL_QNAME: rasqal_literal_type = 13;
pub const rasqal_literal_type_RASQAL_LITERAL_VARIABLE: rasqal_literal_type = 14;
pub const rasqal_literal_type_RASQAL_LITERAL_INTEGER_SUBTYPE: rasqal_literal_type = 15;
pub const rasqal_literal_type_RASQAL_LITERAL_DATE: rasqal_literal_type = 16;
pub const rasqal_literal_type_RASQAL_LITERAL_LAST: rasqal_literal_type = 16;
/// rasqal_literal_type:
/// @RASQAL_LITERAL_BLANK: RDF blank node literal (SPARQL r:bNode)
/// @RASQAL_LITERAL_URI: RDF URI Literal (SPARQL r:URI)
/// @RASQAL_LITERAL_STRING: RDF Plain Literal - no datatype (SPARQL r:Literal)
/// @RASQAL_LITERAL_XSD_STRING: String xsd:string
/// @RASQAL_LITERAL_BOOLEAN: Boolean literal xsd:boolean.
/// @RASQAL_LITERAL_INTEGER: Integer literal xsd:integer.
/// @RASQAL_LITERAL_DOUBLE: Double floating point literal xsd:double.
/// @RASQAL_LITERAL_FLOAT: Floating point literal xsd:float.
/// @RASQAL_LITERAL_DECIMAL: Decimal integer xsd:decimal.
/// @RASQAL_LITERAL_DATETIME: Date/Time literal xsd:dateTime.
/// @RASQAL_LITERAL_UDT: User defined typed literal with unknown datatype URI
/// @RASQAL_LITERAL_PATTERN: Pattern literal for a regex.
/// @RASQAL_LITERAL_QNAME: XML Qname literal.
/// @RASQAL_LITERAL_VARIABLE: Variable literal.
/// @RASQAL_LITERAL_DATE: Date literal xsd:date.
/// @RASQAL_LITERAL_INTEGER_SUBTYPE: Internal.
/// @RASQAL_LITERAL_UNKNOWN: Internal.
/// @RASQAL_LITERAL_FIRST_XSD: Internal.
/// @RASQAL_LITERAL_LAST_XSD: Internal.
/// @RASQAL_LITERAL_LAST: Internal.
///
/// Types of literal.
///
/// The order in the enumeration is significant as it encodes
/// the SPARQL term ordering conditions:
///
///   Blank Nodes << IRIs << RDF literals << typed literals
///
/// which coresponds to in enum values
///
///   BLANK << URI << STRING <<
///     (BOOLEAN | INTEGER | DOUBLE | FLOAT | DECIMAL | DATETIME | XSD_STRING)
///
/// (RASQAL_LITERAL_FIRST_XSD ... RASQAL_LITERAL_LAST_XSD)
///
/// Not used (internal): PATTERN, QNAME, VARIABLE
///
/// See rasqal_literal_compare() when used with flags
/// %RASQAL_COMPARE_XQUERY
pub type rasqal_literal_type = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rasqal_row_s {
    _unused: [u8; 0],
}
/// rasqal_row:
///
/// Rasqal Result Row class.
pub type rasqal_row = rasqal_row_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rasqal_xsd_decimal_s {
    _unused: [u8; 0],
}
/// rasqal_xsd_decimal:
///
/// Rasqal XSD Decimal class.
pub type rasqal_xsd_decimal = rasqal_xsd_decimal_s;
/// rasqal_xsd_date:
/// @year: year
/// @month: month 1-12
/// @day: 1-31
/// @timezone_minutes: minutes +/- against UTC or RASQAL_XSD_DATETIME_NO_TZ if there is no timezone in the dateTime.
/// @time_on_timeline: time on timeline of first instant of date in timezone
/// @have_tz: timezone flag: 'Z' if Zulu, 'Y' if has other timezone offset in @timezone_minutes, 'N' if there is no timezone
///
/// XML schema date datatype (xsd:date)
///
/// Examples of timezone fields:
///  "2010-01-02" : timezone_minutes RASQAL_XSD_DATETIME_NO_TZ, have_tz 'N'
///  "2010-01-02Z" : timezone_minutes 0, have_tz 'Z'
///  "2010-01-02+00:00" : timezone_minutes 0, have_tz 'Y'
///  "2010-01-02-01:00" : timezone_minutes -60, have_tz 'Y'
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rasqal_xsd_date {
    pub year: libc::c_int,
    pub month: libc::c_uchar,
    pub day: libc::c_uchar,
    pub timezone_minutes: libc::c_short,
    pub time_on_timeline: time_t,
    pub have_tz: libc::c_char,
}
#[test]
fn bindgen_test_layout_rasqal_xsd_date() {
    assert_eq!(
        ::std::mem::size_of::<rasqal_xsd_date>(),
        24usize,
        concat!("Size of: ", stringify!(rasqal_xsd_date))
    );
    assert_eq!(
        ::std::mem::align_of::<rasqal_xsd_date>(),
        8usize,
        concat!("Alignment of ", stringify!(rasqal_xsd_date))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_xsd_date>())).year as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_xsd_date),
            "::",
            stringify!(year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_xsd_date>())).month as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_xsd_date),
            "::",
            stringify!(month)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_xsd_date>())).day as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_xsd_date),
            "::",
            stringify!(day)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rasqal_xsd_date>())).timezone_minutes as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_xsd_date),
            "::",
            stringify!(timezone_minutes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rasqal_xsd_date>())).time_on_timeline as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_xsd_date),
            "::",
            stringify!(time_on_timeline)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_xsd_date>())).have_tz as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_xsd_date),
            "::",
            stringify!(have_tz)
        )
    );
}
/// rasqal_xsd_datetime:
/// @year: year
/// @month: month 1-12
/// @day: 1-31
/// @hour: hour 0-23
/// @minute: minute 0-59
/// @second: second 0-60 (yes 60 is allowed for leap seconds)
/// @microseconds: microseconds
/// @timezone_minutes: minutes +/- against UTC or RASQAL_XSD_DATETIME_NO_TZ if there is no timezone in the dateTime.
/// @time_on_timeline: time on timeline
/// @have_tz: timezone flag: 'Z' if Zulu, 'Y' if has other timezone offset in @timezone_minutes, 'N' if there is no timezone
///
/// XML Schema dateTime datatype (xsd:dateTime)
///
/// Signed types are required for normalization process where a value
/// can be negative temporarily.
///
/// Examples of timezone fields:
///  "2010-01-02T01:02:03" : timezone_minutes RASQAL_XSD_DATETIME_NO_TZ, have_tz 'N'
///  "2010-01-02T01:02:03Z" : timezone_minutes 0, have_tz 'Z'
///  "2010-01-02T01:02:03+00:00" : timezone_minutes 0, have_tz 'Y'
///  "2010-01-02T01:02:03-01:00" : timezone_minutes -60, have_tz 'Y'
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rasqal_xsd_datetime {
    pub year: libc::c_int,
    pub month: libc::c_uchar,
    pub day: libc::c_uchar,
    pub hour: libc::c_schar,
    pub minute: libc::c_schar,
    pub second: libc::c_schar,
    pub microseconds: libc::c_int,
    pub timezone_minutes: libc::c_short,
    pub time_on_timeline: time_t,
    pub have_tz: libc::c_char,
}
#[test]
fn bindgen_test_layout_rasqal_xsd_datetime() {
    assert_eq!(
        ::std::mem::size_of::<rasqal_xsd_datetime>(),
        40usize,
        concat!("Size of: ", stringify!(rasqal_xsd_datetime))
    );
    assert_eq!(
        ::std::mem::align_of::<rasqal_xsd_datetime>(),
        8usize,
        concat!("Alignment of ", stringify!(rasqal_xsd_datetime))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_xsd_datetime>())).year as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_xsd_datetime),
            "::",
            stringify!(year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_xsd_datetime>())).month as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_xsd_datetime),
            "::",
            stringify!(month)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_xsd_datetime>())).day as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_xsd_datetime),
            "::",
            stringify!(day)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_xsd_datetime>())).hour as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_xsd_datetime),
            "::",
            stringify!(hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_xsd_datetime>())).minute as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_xsd_datetime),
            "::",
            stringify!(minute)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_xsd_datetime>())).second as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_xsd_datetime),
            "::",
            stringify!(second)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rasqal_xsd_datetime>())).microseconds as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_xsd_datetime),
            "::",
            stringify!(microseconds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rasqal_xsd_datetime>())).timezone_minutes as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_xsd_datetime),
            "::",
            stringify!(timezone_minutes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rasqal_xsd_datetime>())).time_on_timeline as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_xsd_datetime),
            "::",
            stringify!(time_on_timeline)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_xsd_datetime>())).have_tz as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_xsd_datetime),
            "::",
            stringify!(have_tz)
        )
    );
}
/// rasqal_literal:
/// @world: world object pointer
/// @usage: Usage count.
/// @type: Type of literal.
/// @string: String form of literal for literal types UTF-8 string, pattern, qname, blank, double, float, decimal, datetime.
/// @string_len: Length of @string.
/// @value: Alternate value content.
/// @language: Language for string literal type.
/// @datatype: Datatype for string literal type.
/// @flags: Flags for literal types
/// @parent_type: parent XSD type if any or RASQAL_LITERAL_UNKNOWN
/// @valid: >0 if literal format is a valid lexical form for this datatype. 0 if not valid. <0 if this has not been checked yet
///
/// Rasqal literal class.
///
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rasqal_literal_s {
    pub world: *mut rasqal_world,
    pub usage: libc::c_int,
    pub type_: rasqal_literal_type,
    pub string: *const libc::c_uchar,
    pub string_len: libc::c_uint,
    pub value: rasqal_literal_s__bindgen_ty_1,
    pub language: *mut libc::c_char,
    pub datatype: *mut raptor_uri,
    pub flags: *const libc::c_uchar,
    pub parent_type: rasqal_literal_type,
    pub valid: libc::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rasqal_literal_s__bindgen_ty_1 {
    pub integer: libc::c_int,
    pub floating: f64,
    pub uri: *mut raptor_uri,
    pub variable: *mut rasqal_variable,
    pub decimal: *mut rasqal_xsd_decimal,
    pub datetime: *mut rasqal_xsd_datetime,
    pub date: *mut rasqal_xsd_date,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rasqal_literal_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rasqal_literal_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rasqal_literal_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rasqal_literal_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rasqal_literal_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rasqal_literal_s__bindgen_ty_1>())).integer as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_literal_s__bindgen_ty_1),
            "::",
            stringify!(integer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rasqal_literal_s__bindgen_ty_1>())).floating as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_literal_s__bindgen_ty_1),
            "::",
            stringify!(floating)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rasqal_literal_s__bindgen_ty_1>())).uri as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_literal_s__bindgen_ty_1),
            "::",
            stringify!(uri)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rasqal_literal_s__bindgen_ty_1>())).variable as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_literal_s__bindgen_ty_1),
            "::",
            stringify!(variable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rasqal_literal_s__bindgen_ty_1>())).decimal as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_literal_s__bindgen_ty_1),
            "::",
            stringify!(decimal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rasqal_literal_s__bindgen_ty_1>())).datetime as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_literal_s__bindgen_ty_1),
            "::",
            stringify!(datetime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rasqal_literal_s__bindgen_ty_1>())).date as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_literal_s__bindgen_ty_1),
            "::",
            stringify!(date)
        )
    );
}
#[test]
fn bindgen_test_layout_rasqal_literal_s() {
    assert_eq!(
        ::std::mem::size_of::<rasqal_literal_s>(),
        72usize,
        concat!("Size of: ", stringify!(rasqal_literal_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rasqal_literal_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rasqal_literal_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_literal_s>())).world as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_literal_s),
            "::",
            stringify!(world)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_literal_s>())).usage as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_literal_s),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_literal_s>())).type_ as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_literal_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_literal_s>())).string as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_literal_s),
            "::",
            stringify!(string)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_literal_s>())).string_len as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_literal_s),
            "::",
            stringify!(string_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_literal_s>())).value as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_literal_s),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_literal_s>())).language as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_literal_s),
            "::",
            stringify!(language)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_literal_s>())).datatype as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_literal_s),
            "::",
            stringify!(datatype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_literal_s>())).flags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_literal_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_literal_s>())).parent_type as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_literal_s),
            "::",
            stringify!(parent_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_literal_s>())).valid as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_literal_s),
            "::",
            stringify!(valid)
        )
    );
}
pub const rasqal_op_RASQAL_EXPR_UNKNOWN: rasqal_op = 0;
pub const rasqal_op_RASQAL_EXPR_AND: rasqal_op = 1;
pub const rasqal_op_RASQAL_EXPR_OR: rasqal_op = 2;
pub const rasqal_op_RASQAL_EXPR_EQ: rasqal_op = 3;
pub const rasqal_op_RASQAL_EXPR_NEQ: rasqal_op = 4;
pub const rasqal_op_RASQAL_EXPR_LT: rasqal_op = 5;
pub const rasqal_op_RASQAL_EXPR_GT: rasqal_op = 6;
pub const rasqal_op_RASQAL_EXPR_LE: rasqal_op = 7;
pub const rasqal_op_RASQAL_EXPR_GE: rasqal_op = 8;
pub const rasqal_op_RASQAL_EXPR_UMINUS: rasqal_op = 9;
pub const rasqal_op_RASQAL_EXPR_PLUS: rasqal_op = 10;
pub const rasqal_op_RASQAL_EXPR_MINUS: rasqal_op = 11;
pub const rasqal_op_RASQAL_EXPR_STAR: rasqal_op = 12;
pub const rasqal_op_RASQAL_EXPR_SLASH: rasqal_op = 13;
pub const rasqal_op_RASQAL_EXPR_REM: rasqal_op = 14;
pub const rasqal_op_RASQAL_EXPR_STR_EQ: rasqal_op = 15;
pub const rasqal_op_RASQAL_EXPR_STR_NEQ: rasqal_op = 16;
pub const rasqal_op_RASQAL_EXPR_STR_MATCH: rasqal_op = 17;
pub const rasqal_op_RASQAL_EXPR_STR_NMATCH: rasqal_op = 18;
pub const rasqal_op_RASQAL_EXPR_TILDE: rasqal_op = 19;
pub const rasqal_op_RASQAL_EXPR_BANG: rasqal_op = 20;
pub const rasqal_op_RASQAL_EXPR_LITERAL: rasqal_op = 21;
pub const rasqal_op_RASQAL_EXPR_FUNCTION: rasqal_op = 22;
pub const rasqal_op_RASQAL_EXPR_BOUND: rasqal_op = 23;
pub const rasqal_op_RASQAL_EXPR_STR: rasqal_op = 24;
pub const rasqal_op_RASQAL_EXPR_LANG: rasqal_op = 25;
pub const rasqal_op_RASQAL_EXPR_DATATYPE: rasqal_op = 26;
pub const rasqal_op_RASQAL_EXPR_ISURI: rasqal_op = 27;
pub const rasqal_op_RASQAL_EXPR_ISBLANK: rasqal_op = 28;
pub const rasqal_op_RASQAL_EXPR_ISLITERAL: rasqal_op = 29;
pub const rasqal_op_RASQAL_EXPR_CAST: rasqal_op = 30;
pub const rasqal_op_RASQAL_EXPR_ORDER_COND_ASC: rasqal_op = 31;
pub const rasqal_op_RASQAL_EXPR_ORDER_COND_DESC: rasqal_op = 32;
pub const rasqal_op_RASQAL_EXPR_LANGMATCHES: rasqal_op = 33;
pub const rasqal_op_RASQAL_EXPR_REGEX: rasqal_op = 34;
pub const rasqal_op_RASQAL_EXPR_GROUP_COND_ASC: rasqal_op = 35;
pub const rasqal_op_RASQAL_EXPR_GROUP_COND_DESC: rasqal_op = 36;
pub const rasqal_op_RASQAL_EXPR_COUNT: rasqal_op = 37;
pub const rasqal_op_RASQAL_EXPR_VARSTAR: rasqal_op = 38;
pub const rasqal_op_RASQAL_EXPR_SAMETERM: rasqal_op = 39;
pub const rasqal_op_RASQAL_EXPR_SUM: rasqal_op = 40;
pub const rasqal_op_RASQAL_EXPR_AVG: rasqal_op = 41;
pub const rasqal_op_RASQAL_EXPR_MIN: rasqal_op = 42;
pub const rasqal_op_RASQAL_EXPR_MAX: rasqal_op = 43;
pub const rasqal_op_RASQAL_EXPR_COALESCE: rasqal_op = 44;
pub const rasqal_op_RASQAL_EXPR_IF: rasqal_op = 45;
pub const rasqal_op_RASQAL_EXPR_URI: rasqal_op = 46;
pub const rasqal_op_RASQAL_EXPR_IRI: rasqal_op = 47;
pub const rasqal_op_RASQAL_EXPR_STRLANG: rasqal_op = 48;
pub const rasqal_op_RASQAL_EXPR_STRDT: rasqal_op = 49;
pub const rasqal_op_RASQAL_EXPR_BNODE: rasqal_op = 50;
pub const rasqal_op_RASQAL_EXPR_GROUP_CONCAT: rasqal_op = 51;
pub const rasqal_op_RASQAL_EXPR_SAMPLE: rasqal_op = 52;
pub const rasqal_op_RASQAL_EXPR_IN: rasqal_op = 53;
pub const rasqal_op_RASQAL_EXPR_NOT_IN: rasqal_op = 54;
pub const rasqal_op_RASQAL_EXPR_ISNUMERIC: rasqal_op = 55;
pub const rasqal_op_RASQAL_EXPR_YEAR: rasqal_op = 56;
pub const rasqal_op_RASQAL_EXPR_MONTH: rasqal_op = 57;
pub const rasqal_op_RASQAL_EXPR_DAY: rasqal_op = 58;
pub const rasqal_op_RASQAL_EXPR_HOURS: rasqal_op = 59;
pub const rasqal_op_RASQAL_EXPR_MINUTES: rasqal_op = 60;
pub const rasqal_op_RASQAL_EXPR_SECONDS: rasqal_op = 61;
pub const rasqal_op_RASQAL_EXPR_TIMEZONE: rasqal_op = 62;
pub const rasqal_op_RASQAL_EXPR_CURRENT_DATETIME: rasqal_op = 63;
pub const rasqal_op_RASQAL_EXPR_NOW: rasqal_op = 64;
pub const rasqal_op_RASQAL_EXPR_FROM_UNIXTIME: rasqal_op = 65;
pub const rasqal_op_RASQAL_EXPR_TO_UNIXTIME: rasqal_op = 66;
pub const rasqal_op_RASQAL_EXPR_CONCAT: rasqal_op = 67;
pub const rasqal_op_RASQAL_EXPR_STRLEN: rasqal_op = 68;
pub const rasqal_op_RASQAL_EXPR_SUBSTR: rasqal_op = 69;
pub const rasqal_op_RASQAL_EXPR_UCASE: rasqal_op = 70;
pub const rasqal_op_RASQAL_EXPR_LCASE: rasqal_op = 71;
pub const rasqal_op_RASQAL_EXPR_STRSTARTS: rasqal_op = 72;
pub const rasqal_op_RASQAL_EXPR_STRENDS: rasqal_op = 73;
pub const rasqal_op_RASQAL_EXPR_CONTAINS: rasqal_op = 74;
pub const rasqal_op_RASQAL_EXPR_ENCODE_FOR_URI: rasqal_op = 75;
pub const rasqal_op_RASQAL_EXPR_TZ: rasqal_op = 76;
pub const rasqal_op_RASQAL_EXPR_RAND: rasqal_op = 77;
pub const rasqal_op_RASQAL_EXPR_ABS: rasqal_op = 78;
pub const rasqal_op_RASQAL_EXPR_ROUND: rasqal_op = 79;
pub const rasqal_op_RASQAL_EXPR_CEIL: rasqal_op = 80;
pub const rasqal_op_RASQAL_EXPR_FLOOR: rasqal_op = 81;
pub const rasqal_op_RASQAL_EXPR_MD5: rasqal_op = 82;
pub const rasqal_op_RASQAL_EXPR_SHA1: rasqal_op = 83;
pub const rasqal_op_RASQAL_EXPR_SHA224: rasqal_op = 84;
pub const rasqal_op_RASQAL_EXPR_SHA256: rasqal_op = 85;
pub const rasqal_op_RASQAL_EXPR_SHA384: rasqal_op = 86;
pub const rasqal_op_RASQAL_EXPR_SHA512: rasqal_op = 87;
pub const rasqal_op_RASQAL_EXPR_STRBEFORE: rasqal_op = 88;
pub const rasqal_op_RASQAL_EXPR_STRAFTER: rasqal_op = 89;
pub const rasqal_op_RASQAL_EXPR_REPLACE: rasqal_op = 90;
pub const rasqal_op_RASQAL_EXPR_UUID: rasqal_op = 91;
pub const rasqal_op_RASQAL_EXPR_STRUUID: rasqal_op = 92;
pub const rasqal_op_RASQAL_EXPR_LAST: rasqal_op = 92;
/// rasqal_op:
/// @RASQAL_EXPR_AND: Expression for AND(A, B)
/// @RASQAL_EXPR_OR: Expression for OR(A, B)
/// @RASQAL_EXPR_EQ: Expression for A equals B
/// @RASQAL_EXPR_NEQ: Expression for A not equals B.
/// @RASQAL_EXPR_LT: Expression for A less than B.
/// @RASQAL_EXPR_GT: Expression for A greather than B.
/// @RASQAL_EXPR_LE: Expression for A less than or equal to B.
/// @RASQAL_EXPR_GE: Expression for A greater than or equal to B.
/// @RASQAL_EXPR_UMINUS: Expression for -A.
/// @RASQAL_EXPR_PLUS: Expression for +A.
/// @RASQAL_EXPR_MINUS: Expression for A-B.
/// @RASQAL_EXPR_STAR: Expression for A*B.
/// @RASQAL_EXPR_SLASH: Expression for A/B.
/// @RASQAL_EXPR_REM: Expression for A/B remainder.
/// @RASQAL_EXPR_STR_EQ: Expression for A string equals B.
/// @RASQAL_EXPR_STR_NEQ: Expression for A string not-equals B.
/// @RASQAL_EXPR_STR_MATCH: Expression for string A matches literal regex B with flags.
/// @RASQAL_EXPR_STR_NMATCH: Expression for string A not-matches literal regex B with flags.
/// @RASQAL_EXPR_REGEX: Expression for string A matches expression regex B with flags.
/// @RASQAL_EXPR_TILDE: Expression for binary not A.
/// @RASQAL_EXPR_BANG: Expression for logical not A.
/// @RASQAL_EXPR_LITERAL: Expression for a #rasqal_literal.
/// @RASQAL_EXPR_FUNCTION: Expression for a function A with arguments (B...).
/// @RASQAL_EXPR_BOUND: Expression for SPARQL ISBOUND(A).
/// @RASQAL_EXPR_STR: Expression for SPARQL STR(A).
/// @RASQAL_EXPR_LANG: Expression for SPARQL LANG(A).
/// @RASQAL_EXPR_LANGMATCHES: Expression for SPARQL LANGMATCHES(A, B).
/// @RASQAL_EXPR_DATATYPE: Expression for SPARQL DATATYPE(A).
/// @RASQAL_EXPR_ISURI: Expression for SPARQL ISURI(A).
/// @RASQAL_EXPR_ISBLANK: Expression for SPARQL ISBLANK(A).
/// @RASQAL_EXPR_ISLITERAL: Expression for SPARQL ISLITERAL(A).
/// @RASQAL_EXPR_CAST: Expression for cast literal A to type B.
/// @RASQAL_EXPR_ORDER_COND_ASC: Expression for SPARQL order condition ascending.
/// @RASQAL_EXPR_ORDER_COND_DESC: Expression for SPARQL order condition descending.
/// @RASQAL_EXPR_GROUP_COND_ASC: Obsolete - not used
/// @RASQAL_EXPR_GROUP_COND_DESC: Obsolete - not used
/// @RASQAL_EXPR_COUNT: Expression for LAQRS select COUNT() aggregate function
/// @RASQAL_EXPR_VARSTAR: Expression for LAQRS select Variable *
/// @RASQAL_EXPR_SAMETERM: Expression for SPARQL sameTerm
/// @RASQAL_EXPR_SUM: Expression for LAQRS select SUM() aggregate function
/// @RASQAL_EXPR_AVG: Expression for LAQRS select AVG() aggregate function
/// @RASQAL_EXPR_MIN: Expression for LAQRS select MIN() aggregate function
/// @RASQAL_EXPR_MAX: Expression for LAQRS select MAX() aggregate function
/// @RASQAL_EXPR_COALESCE: Expression for LAQRS COALESCE(Expr+)
/// @RASQAL_EXPR_IF: Expression for LAQRS IF(expr, expr, expr)
/// @RASQAL_EXPR_URI: Expression for LAQRS URI(expr)
/// @RASQAL_EXPR_IRI: Expression for LAQRS IRI(expr)
/// @RASQAL_EXPR_STRLANG: Expression for LAQRS STRLANG(expr, expr)
/// @RASQAL_EXPR_STRDT: Expression for LAQRS STRDT(expr, expr)
/// @RASQAL_EXPR_BNODE: Expression for LAQRS BNODE() and BNODE(expr)
/// @RASQAL_EXPR_GROUP_CONCAT: Expression for LAQRS GROUP_CONCAT(arglist) aggregate function
/// @RASQAL_EXPR_SAMPLE: Expression for LAQRS SAMPLE(expr) aggregate function
/// @RASQAL_EXPR_IN: Expression for LAQRS expr IN ( list of expr )
/// @RASQAL_EXPR_NOT_IN: Expression for LAQRS expr NOT IN ( list of expr )
/// @RASQAL_EXPR_ISNUMERIC: Expression for SPARQL 1.1 isNUMERIC(expr)
/// @RASQAL_EXPR_YEAR: Expression for SPARQL 1.1 YEAR(datetime)
/// @RASQAL_EXPR_MONTH: Expression for SPARQL 1.1 MONTH(datetime)
/// @RASQAL_EXPR_DAY: Expression for SPARQL 1.1 DAY(datetime)
/// @RASQAL_EXPR_HOURS: Expression for SPARQL 1.1 HOURS(datetime)
/// @RASQAL_EXPR_MINUTES: Expression for SPARQL 1.1 MINUTES(datetime)
/// @RASQAL_EXPR_SECONDS: Expression for SPARQL 1.1 SECONDS(datetime)
/// @RASQAL_EXPR_TIMEZONE: Expression for SPARQL 1.1 TIMEZONE(datetime)
/// @RASQAL_EXPR_CURRENT_DATETIME: Expression for LAQRS CURRENT_DATETIME( void )
/// @RASQAL_EXPR_NOW: Expression for LAQRS NOW( void )
/// @RASQAL_EXPR_FROM_UNIXTIME: Expression for LAQRS FROM_UNIXTIME(int)
/// @RASQAL_EXPR_TO_UNIXTIME: Expression for LAQRS TO_UNIXTIME(datetime)
/// @RASQAL_EXPR_CONCAT: Expression for SPARQL 1.1 CONCAT(strings)
/// @RASQAL_EXPR_STRLEN: Expression for SPARQL 1.1 STRLEN(str)
/// @RASQAL_EXPR_SUBSTR: Expression for SPARQL 1.1 SUBSTR(str, start[,offset])
/// @RASQAL_EXPR_UCASE: Expression for SPARQL 1.1 UCASE(str)
/// @RASQAL_EXPR_LCASE: Expression for SPARQL 1.1 LCASE(str)
/// @RASQAL_EXPR_STRSTARTS: Expression for SPARQL 1.1 STRSTARTS(str, str)
/// @RASQAL_EXPR_STRENDS: Expression for SPARQL 1.1 STRENDS(str, str)
/// @RASQAL_EXPR_CONTAINS: Expression for SPARQL 1.1 CONTAINS(str, str)
/// @RASQAL_EXPR_ENCODE_FOR_URI: Expression for SPARQL 1.1 ENCODE_FOR_URI(str)
/// @RASQAL_EXPR_TZ: Expression for SPARQL 1.1 TZ()
/// @RASQAL_EXPR_RAND: Expression for SPARQL 1.1 RAND()
/// @RASQAL_EXPR_ABS: Expression for SPARQL 1.1 ABS()
/// @RASQAL_EXPR_ROUND: Expression for SPARQL 1.1 ROUND()
/// @RASQAL_EXPR_CEIL: Expression for SPARQL 1.1 CEIL()
/// @RASQAL_EXPR_FLOOR: Expression for SPARQL 1.1 FLOOR()
/// @RASQAL_EXPR_MD5: Expression for SPARQL 1.1 MD5()
/// @RASQAL_EXPR_SHA1: Expression for SPARQL 1.1 SHA1()
/// @RASQAL_EXPR_SHA224: Expression for SPARQL 1.1 SHA224()
/// @RASQAL_EXPR_SHA256: Expression for SPARQL 1.1 SHA256()
/// @RASQAL_EXPR_SHA384: Expression for SPARQL 1.1 SHA384()
/// @RASQAL_EXPR_SHA512: Expression for SPARQL 1.1 SHA512()
/// @RASQAL_EXPR_STRBEFORE: Expression for SPARQL 1.1 STRBEFORE()
/// @RASQAL_EXPR_STRAFTER: Expression for SPARQL 1.1 STRAFTER()
/// @RASQAL_EXPR_REPLACE: Expression for SPARQL 1.1 REPLACE()
/// @RASQAL_EXPR_UUID: Expression for SPARQL 1.1 UUID()
/// @RASQAL_EXPR_STRUUID: Expression for SPARQL 1.1 STRUUID()
/// @RASQAL_EXPR_UNKNOWN: Internal
/// @RASQAL_EXPR_LAST: Internal
///
/// Rasqal expression operators.  A mixture of unary, binary and
/// tertiary operators (string matches).  Also includes casting and
/// two ordering operators from ORDER BY in SPARQL.
pub type rasqal_op = u32;
pub const rasqal_expression_flags_RASQAL_EXPR_FLAG_DISTINCT: rasqal_expression_flags = 1;
pub const rasqal_expression_flags_RASQAL_EXPR_FLAG_AGGREGATE: rasqal_expression_flags = 2;
/// rasqal_expression_flags:
/// @RASQAL_EXPR_FLAG_DISTINCT: Distinct
/// @RASQAL_EXPR_FLAG_AGGREGATE: Aggregate function expression
///
/// Flags for expressions.
pub type rasqal_expression_flags = u32;
/// rasqal_expression:
/// @world: rasqal_world object
/// @usage: reference count - 1 for itself
/// @op: expression operation
/// @arg1: first argument
/// @arg2: second argument
/// @arg3: third argument (for #RASQAL_EXPR_REGEX )
/// @literal: literal argument
/// @value: UTF-8 value
/// @name: name for extension function qname(args...) and cast-to-uri
/// @args: args for extension function qname(args...), cast-to-uri and COALESCE
/// @params: args for extension function parameters (SPARQL 1.1) (Rasqal 0.9.20+)
/// @flags: bitflags from #rasqal_expression_flags for expressions (Rasqal 0.9.20+)
/// @arg4: fourth argument (for #RASQAL_EXPR_REPLACE )
///
/// Expression with arguments
///
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rasqal_expression_s {
    pub world: *mut rasqal_world,
    pub usage: libc::c_int,
    pub op: rasqal_op,
    pub arg1: *mut rasqal_expression_s,
    pub arg2: *mut rasqal_expression_s,
    pub arg3: *mut rasqal_expression_s,
    pub literal: *mut rasqal_literal,
    pub value: *mut libc::c_uchar,
    pub name: *mut raptor_uri,
    pub args: *mut raptor_sequence,
    pub params: *mut raptor_sequence,
    pub flags: libc::c_uint,
    pub arg4: *mut rasqal_expression_s,
}
#[test]
fn bindgen_test_layout_rasqal_expression_s() {
    assert_eq!(
        ::std::mem::size_of::<rasqal_expression_s>(),
        96usize,
        concat!("Size of: ", stringify!(rasqal_expression_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rasqal_expression_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rasqal_expression_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_expression_s>())).world as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_expression_s),
            "::",
            stringify!(world)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_expression_s>())).usage as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_expression_s),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_expression_s>())).op as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_expression_s),
            "::",
            stringify!(op)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_expression_s>())).arg1 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_expression_s),
            "::",
            stringify!(arg1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_expression_s>())).arg2 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_expression_s),
            "::",
            stringify!(arg2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_expression_s>())).arg3 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_expression_s),
            "::",
            stringify!(arg3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_expression_s>())).literal as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_expression_s),
            "::",
            stringify!(literal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_expression_s>())).value as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_expression_s),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_expression_s>())).name as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_expression_s),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_expression_s>())).args as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_expression_s),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_expression_s>())).params as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_expression_s),
            "::",
            stringify!(params)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_expression_s>())).flags as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_expression_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_expression_s>())).arg4 as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_expression_s),
            "::",
            stringify!(arg4)
        )
    );
}
pub type rasqal_expression = rasqal_expression_s;
/// rasqal_triple:
/// @subject: Triple subject.
/// @predicate: Triple predicate.
/// @object: Triple object.
/// @origin: Triple origin.
/// @flags: Or of enum #rasqal_triple_flags bits.
///
/// A triple pattern or RDF triple.
///
/// This is used as a triple pattern in queries and
/// an RDF triple when generating RDF triples such as with SPARQL CONSTRUCT.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rasqal_triple {
    pub subject: *mut rasqal_literal,
    pub predicate: *mut rasqal_literal,
    pub object: *mut rasqal_literal,
    pub origin: *mut rasqal_literal,
    pub flags: libc::c_uint,
}
#[test]
fn bindgen_test_layout_rasqal_triple() {
    assert_eq!(
        ::std::mem::size_of::<rasqal_triple>(),
        40usize,
        concat!("Size of: ", stringify!(rasqal_triple))
    );
    assert_eq!(
        ::std::mem::align_of::<rasqal_triple>(),
        8usize,
        concat!("Alignment of ", stringify!(rasqal_triple))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_triple>())).subject as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_triple),
            "::",
            stringify!(subject)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_triple>())).predicate as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_triple),
            "::",
            stringify!(predicate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_triple>())).object as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_triple),
            "::",
            stringify!(object)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_triple>())).origin as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_triple),
            "::",
            stringify!(origin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_triple>())).flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_triple),
            "::",
            stringify!(flags)
        )
    );
}
pub const rasqal_pattern_flags_RASQAL_PATTERN_FLAGS_OPTIONAL: rasqal_pattern_flags = 1;
pub const rasqal_pattern_flags_RASQAL_PATTERN_FLAGS_LAST: rasqal_pattern_flags = 1;
/// rasqal_pattern_flags:
/// @RASQAL_PATTERN_FLAGS_OPTIONAL: True when the graph pattern is an optional match.
/// @RASQAL_PATTERN_FLAGS_LAST: Internal
///
/// Flags for #rasqal_graph_pattern.
pub type rasqal_pattern_flags = u32;
/// rasqal_generate_bnodeid_handler:
/// @world: world arg
/// @user_data: user data given to
/// @user_bnodeid: user blank node ID string passed in
///
/// User handler used with rasqal_world_set_generate_bnodeid_handler() to set method for generating a blank node ID.
///
/// Return value: blank node ID string or NULL on failure.
pub type rasqal_generate_bnodeid_handler = ::std::option::Option<
    unsafe extern "C" fn(
        world: *mut rasqal_world,
        user_data: *mut libc::c_void,
        user_bnodeid: *mut libc::c_uchar,
    ) -> *mut libc::c_uchar,
>;
pub const rasqal_query_verb_RASQAL_QUERY_VERB_UNKNOWN: rasqal_query_verb = 0;
pub const rasqal_query_verb_RASQAL_QUERY_VERB_SELECT: rasqal_query_verb = 1;
pub const rasqal_query_verb_RASQAL_QUERY_VERB_CONSTRUCT: rasqal_query_verb = 2;
pub const rasqal_query_verb_RASQAL_QUERY_VERB_DESCRIBE: rasqal_query_verb = 3;
pub const rasqal_query_verb_RASQAL_QUERY_VERB_ASK: rasqal_query_verb = 4;
pub const rasqal_query_verb_RASQAL_QUERY_VERB_DELETE: rasqal_query_verb = 5;
pub const rasqal_query_verb_RASQAL_QUERY_VERB_INSERT: rasqal_query_verb = 6;
pub const rasqal_query_verb_RASQAL_QUERY_VERB_UPDATE: rasqal_query_verb = 7;
pub const rasqal_query_verb_RASQAL_QUERY_VERB_LAST: rasqal_query_verb = 7;
/// rasqal_query_verb:
/// @RASQAL_QUERY_VERB_SELECT: SPARQL query select verb.
/// @RASQAL_QUERY_VERB_CONSTRUCT: SPARQL query construct verb.
/// @RASQAL_QUERY_VERB_DESCRIBE: SPARQL query describe verb.
/// @RASQAL_QUERY_VERB_ASK: SPARQL query ask verb.
/// @RASQAL_QUERY_VERB_DELETE: LAQRS query delete verb.
/// @RASQAL_QUERY_VERB_INSERT: LAQRS query insert verb.
/// @RASQAL_QUERY_VERB_UPDATE: SPARQL 1.1 (draft) update operation
/// @RASQAL_QUERY_VERB_UNKNOWN: Internal
/// @RASQAL_QUERY_VERB_LAST: Internal
///
/// Query main operation verbs describing the major type of query
/// being performed.
pub type rasqal_query_verb = u32;
pub const rasqal_query_results_type_RASQAL_QUERY_RESULTS_BINDINGS: rasqal_query_results_type = 0;
pub const rasqal_query_results_type_RASQAL_QUERY_RESULTS_BOOLEAN: rasqal_query_results_type = 1;
pub const rasqal_query_results_type_RASQAL_QUERY_RESULTS_GRAPH: rasqal_query_results_type = 2;
pub const rasqal_query_results_type_RASQAL_QUERY_RESULTS_SYNTAX: rasqal_query_results_type = 3;
pub const rasqal_query_results_type_RASQAL_QUERY_RESULTS_UNKNOWN: rasqal_query_results_type = 4;
pub const rasqal_query_results_type_RASQAL_QUERY_RESULTS_LAST: rasqal_query_results_type = 4;
/// rasqal_query_results_type:
/// @RASQAL_QUERY_RESULTS_BINDINGS: variable binding
/// @RASQAL_QUERY_RESULTS_BOOLEAN: a single boolean
/// @RASQAL_QUERY_RESULTS_GRAPH: an RDF graph
/// @RASQAL_QUERY_RESULTS_SYNTAX: a syntax
/// @RASQAL_QUERY_RESULTS_UNKNOWN: unknown type
/// @RASQAL_QUERY_RESULTS_LAST: internal
///
/// Query result type.
pub type rasqal_query_results_type = u32;
pub const rasqal_update_type_RASQAL_UPDATE_TYPE_UNKNOWN: rasqal_update_type = 0;
pub const rasqal_update_type_RASQAL_UPDATE_TYPE_CLEAR: rasqal_update_type = 1;
pub const rasqal_update_type_RASQAL_UPDATE_TYPE_CREATE: rasqal_update_type = 2;
pub const rasqal_update_type_RASQAL_UPDATE_TYPE_DROP: rasqal_update_type = 3;
pub const rasqal_update_type_RASQAL_UPDATE_TYPE_LOAD: rasqal_update_type = 4;
pub const rasqal_update_type_RASQAL_UPDATE_TYPE_UPDATE: rasqal_update_type = 5;
pub const rasqal_update_type_RASQAL_UPDATE_TYPE_ADD: rasqal_update_type = 6;
pub const rasqal_update_type_RASQAL_UPDATE_TYPE_MOVE: rasqal_update_type = 7;
pub const rasqal_update_type_RASQAL_UPDATE_TYPE_COPY: rasqal_update_type = 8;
pub const rasqal_update_type_RASQAL_UPDATE_TYPE_LAST: rasqal_update_type = 8;
/// rasqal_update_type:
/// @RASQAL_UPDATE_TYPE_CLEAR: Clear graph.
/// @RASQAL_UPDATE_TYPE_CREATE: Create graph.
/// @RASQAL_UPDATE_TYPE_DROP: Drop graph.
/// @RASQAL_UPDATE_TYPE_LOAD: Load graph.
/// @RASQAL_UPDATE_TYPE_UPDATE: Insert or Delete graph or triples.
/// @RASQAL_UPDATE_TYPE_ADD: Add graph to another graph.
/// @RASQAL_UPDATE_TYPE_MOVE: Move graph to another grpah.
/// @RASQAL_UPDATE_TYPE_COPY: Copy graph to another graph.
/// @RASQAL_UPDATE_TYPE_UNKNOWN: Internal
/// @RASQAL_UPDATE_TYPE_LAST: Internal
///
/// Update type being performed.
///
pub type rasqal_update_type = u32;
pub const rasqal_update_flags_RASQAL_UPDATE_FLAGS_SILENT: rasqal_update_flags = 1;
pub const rasqal_update_flags_RASQAL_UPDATE_FLAGS_DATA: rasqal_update_flags = 2;
/// rasqal_update_flags:
/// @RASQAL_UPDATE_FLAGS_SILENT: the update operation should be silent
/// @RASQAL_UPDATE_FLAGS_DATA: the update operation is triple data not templates
///
/// Bitflags for graph update operations
pub type rasqal_update_flags = u32;
pub const rasqal_update_graph_applies_RASQAL_UPDATE_GRAPH_ONE: rasqal_update_graph_applies = 0;
pub const rasqal_update_graph_applies_RASQAL_UPDATE_GRAPH_DEFAULT: rasqal_update_graph_applies = 1;
pub const rasqal_update_graph_applies_RASQAL_UPDATE_GRAPH_NAMED: rasqal_update_graph_applies = 2;
pub const rasqal_update_graph_applies_RASQAL_UPDATE_GRAPH_ALL: rasqal_update_graph_applies = 3;
/// rasqal_update_graph_applies:
/// @RASQAL_UPDATE_GRAPH_ONE: the update operation applies to 1 graph
/// @RASQAL_UPDATE_GRAPH_DEFAULT: the update operation applies to the default graph
/// @RASQAL_UPDATE_GRAPH_NAMED: the update operation applies to all named graphs
/// @RASQAL_UPDATE_GRAPH_ALL: the update operation applies ALL graphs
///
/// The graph(s) that the update operation applies to.
pub type rasqal_update_graph_applies = u32;
/// rasqal_update_operation:
/// @type: type of update
/// @graph_uri: optional graph URI (clear, drop, load, with ... delete, insert); source graph (add, move, copy)
/// @document_uri: optional document URI (load); destination graph (add, move, copy)
/// @insert_templates: optional sequence of #rasqal_triple to insert. Data triples if @flags is #RASQAL_UPDATE_FLAGS_DATA set, templates otherwise.
/// @delete_templates: optional sequence of #rasqal_triple templates to delete
/// @where: optional where template (insert/delete)
/// @flags: update flags - bit-or of flags defined in #rasqal_update_flags
/// @applies: the graph(s) that the update operation applies to, or @graph_uri if #RASQAL_UPDATE_GRAPH_ONE
///
/// Update operation - changing the dataset
///
/// For LOAD and CLEAR if @applies is set (not 0) then the operation
/// applies to just those graph(), otherwise it applies to the @graph_uri.
///
/// For ADD, MOVE and COPY the source graph is stored in @graph_uri
/// field and the destination graph in the @document_uri field.  The
/// field names have no meaning in this case since both values are
/// always present, always graphs and a NULL value signifies the
/// default graph.
///
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rasqal_update_operation {
    pub type_: rasqal_update_type,
    pub graph_uri: *mut raptor_uri,
    pub document_uri: *mut raptor_uri,
    pub insert_templates: *mut raptor_sequence,
    pub delete_templates: *mut raptor_sequence,
    pub where_: *mut rasqal_graph_pattern,
    pub flags: libc::c_int,
    pub applies: rasqal_update_graph_applies,
}
#[test]
fn bindgen_test_layout_rasqal_update_operation() {
    assert_eq!(
        ::std::mem::size_of::<rasqal_update_operation>(),
        56usize,
        concat!("Size of: ", stringify!(rasqal_update_operation))
    );
    assert_eq!(
        ::std::mem::align_of::<rasqal_update_operation>(),
        8usize,
        concat!("Alignment of ", stringify!(rasqal_update_operation))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_update_operation>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_update_operation),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rasqal_update_operation>())).graph_uri as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_update_operation),
            "::",
            stringify!(graph_uri)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rasqal_update_operation>())).document_uri as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_update_operation),
            "::",
            stringify!(document_uri)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rasqal_update_operation>())).insert_templates as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_update_operation),
            "::",
            stringify!(insert_templates)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rasqal_update_operation>())).delete_templates as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_update_operation),
            "::",
            stringify!(delete_templates)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_update_operation>())).where_ as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_update_operation),
            "::",
            stringify!(where_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_update_operation>())).flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_update_operation),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_update_operation>())).applies as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_update_operation),
            "::",
            stringify!(applies)
        )
    );
}
pub const rasqal_graph_pattern_operator_RASQAL_GRAPH_PATTERN_OPERATOR_UNKNOWN:
    rasqal_graph_pattern_operator = 0;
pub const rasqal_graph_pattern_operator_RASQAL_GRAPH_PATTERN_OPERATOR_BASIC:
    rasqal_graph_pattern_operator = 1;
pub const rasqal_graph_pattern_operator_RASQAL_GRAPH_PATTERN_OPERATOR_OPTIONAL:
    rasqal_graph_pattern_operator = 2;
pub const rasqal_graph_pattern_operator_RASQAL_GRAPH_PATTERN_OPERATOR_UNION:
    rasqal_graph_pattern_operator = 3;
pub const rasqal_graph_pattern_operator_RASQAL_GRAPH_PATTERN_OPERATOR_GROUP:
    rasqal_graph_pattern_operator = 4;
pub const rasqal_graph_pattern_operator_RASQAL_GRAPH_PATTERN_OPERATOR_GRAPH:
    rasqal_graph_pattern_operator = 5;
pub const rasqal_graph_pattern_operator_RASQAL_GRAPH_PATTERN_OPERATOR_FILTER:
    rasqal_graph_pattern_operator = 6;
pub const rasqal_graph_pattern_operator_RASQAL_GRAPH_PATTERN_OPERATOR_LET:
    rasqal_graph_pattern_operator = 7;
pub const rasqal_graph_pattern_operator_RASQAL_GRAPH_PATTERN_OPERATOR_SELECT:
    rasqal_graph_pattern_operator = 8;
pub const rasqal_graph_pattern_operator_RASQAL_GRAPH_PATTERN_OPERATOR_SERVICE:
    rasqal_graph_pattern_operator = 9;
pub const rasqal_graph_pattern_operator_RASQAL_GRAPH_PATTERN_OPERATOR_MINUS:
    rasqal_graph_pattern_operator = 10;
pub const rasqal_graph_pattern_operator_RASQAL_GRAPH_PATTERN_OPERATOR_VALUES:
    rasqal_graph_pattern_operator = 11;
pub const rasqal_graph_pattern_operator_RASQAL_GRAPH_PATTERN_OPERATOR_LAST:
    rasqal_graph_pattern_operator = 11;
/// rasqal_graph_pattern_operator:
/// @RASQAL_GRAPH_PATTERN_OPERATOR_BASIC: Just triple patterns and constraints.
/// @RASQAL_GRAPH_PATTERN_OPERATOR_OPTIONAL: Set of graph patterns (ANDed) and constraints.
/// @RASQAL_GRAPH_PATTERN_OPERATOR_UNION: Set of graph patterns (UNIONed) and constraints.
/// @RASQAL_GRAPH_PATTERN_OPERATOR_GROUP: Set of graph patterns (ANDed) and constraints.
/// @RASQAL_GRAPH_PATTERN_OPERATOR_GRAPH: A graph term + a graph pattern and constraints.
/// @RASQAL_GRAPH_PATTERN_OPERATOR_FILTER: A filter graph pattern with an expression
/// @RASQAL_GRAPH_PATTERN_OPERATOR_LET: LET ?var := Expression (LAQRS)
/// @RASQAL_GRAPH_PATTERN_OPERATOR_SELECT: SELECT graph pattern
/// @RASQAL_GRAPH_PATTERN_OPERATOR_SERVICE: SERVICE graph pattern
/// @RASQAL_GRAPH_PATTERN_OPERATOR_MINUS: MINUS graph pattern
/// @RASQAL_GRAPH_PATTERN_OPERATOR_VALUES: VALUES graph pattern
/// @RASQAL_GRAPH_PATTERN_OPERATOR_UNKNOWN: Internal.
/// @RASQAL_GRAPH_PATTERN_OPERATOR_LAST: Internal.
///
/// Graph pattern operators
pub type rasqal_graph_pattern_operator = u32;
/// rasqal_graph_pattern_visit_fn:
/// @query: #rasqal_query containing the graph pattern
/// @gp: current graph_pattern
/// @user_data: user data passed in
///
/// User function to visit an graph_pattern and operate on it with
/// rasqal_graph_pattern_visit() or rasqal_query_graph_pattern_visit()
///
/// Return value: non-0 to truncate the visit
pub type rasqal_graph_pattern_visit_fn = ::std::option::Option<
    unsafe extern "C" fn(
        query: *mut rasqal_query,
        gp: *mut rasqal_graph_pattern,
        user_data: *mut libc::c_void,
    ) -> libc::c_int,
>;
extern "C" {
    pub fn rasqal_new_world() -> *mut rasqal_world;
}
extern "C" {
    pub fn rasqal_world_open(world: *mut rasqal_world) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_free_world(world: *mut rasqal_world);
}
extern "C" {
    pub fn rasqal_world_set_raptor(world: *mut rasqal_world, raptor_world_ptr: *mut raptor_world);
}
extern "C" {
    pub fn rasqal_world_get_raptor(world: *mut rasqal_world) -> *mut raptor_world;
}
extern "C" {
    pub fn rasqal_world_set_log_handler(
        world: *mut rasqal_world,
        user_data: *mut libc::c_void,
        handler: raptor_log_handler,
    );
}
extern "C" {
    pub fn rasqal_world_set_default_generate_bnodeid_parameters(
        world: *mut rasqal_world,
        prefix: *mut libc::c_char,
        base: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_world_set_generate_bnodeid_handler(
        world: *mut rasqal_world,
        user_data: *mut libc::c_void,
        handler: rasqal_generate_bnodeid_handler,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_world_set_warning_level(
        world: *mut rasqal_world,
        warning_level: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_world_get_query_results_format_description(
        world: *mut rasqal_world,
        counter: libc::c_uint,
    ) -> *const raptor_syntax_description;
}
extern "C" {
    pub fn rasqal_world_guess_query_results_format_name(
        world: *mut rasqal_world,
        uri: *mut raptor_uri,
        mime_type: *const libc::c_char,
        buffer: *const libc::c_uchar,
        len: usize,
        identifier: *const libc::c_uchar,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn rasqal_features_enumerate(
        world: *mut rasqal_world,
        feature: rasqal_feature,
        name: *mut *const libc::c_char,
        uri: *mut *mut raptor_uri,
        label: *mut *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_get_feature_count() -> libc::c_uint;
}
extern "C" {
    pub fn rasqal_feature_from_uri(
        world: *mut rasqal_world,
        uri: *mut raptor_uri,
    ) -> rasqal_feature;
}
extern "C" {
    pub fn rasqal_feature_value_type(feature: rasqal_feature) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_world_get_query_language_description(
        world: *mut rasqal_world,
        counter: libc::c_uint,
    ) -> *const raptor_syntax_description;
}
extern "C" {
    pub fn rasqal_languages_enumerate(
        world: *mut rasqal_world,
        counter: libc::c_uint,
        name: *mut *const libc::c_char,
        label: *mut *const libc::c_char,
        uri_string: *mut *const libc::c_uchar,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_language_name_check(
        world: *mut rasqal_world,
        name: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_new_query(
        world: *mut rasqal_world,
        name: *const libc::c_char,
        uri: *const libc::c_uchar,
    ) -> *mut rasqal_query;
}
extern "C" {
    pub fn rasqal_free_query(query: *mut rasqal_query);
}
extern "C" {
    pub fn rasqal_query_get_name(query: *mut rasqal_query) -> *const libc::c_char;
}
extern "C" {
    pub fn rasqal_query_get_label(query: *mut rasqal_query) -> *const libc::c_char;
}
extern "C" {
    pub fn rasqal_query_set_feature(
        query: *mut rasqal_query,
        feature: rasqal_feature,
        value: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_query_set_feature_string(
        query: *mut rasqal_query,
        feature: rasqal_feature,
        value: *const libc::c_uchar,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_query_get_feature(
        query: *mut rasqal_query,
        feature: rasqal_feature,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_query_get_feature_string(
        query: *mut rasqal_query,
        feature: rasqal_feature,
    ) -> *const libc::c_uchar;
}
extern "C" {
    pub fn rasqal_query_get_verb(query: *mut rasqal_query) -> rasqal_query_verb;
}
extern "C" {
    pub fn rasqal_query_get_wildcard(query: *mut rasqal_query) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_query_set_wildcard(query: *mut rasqal_query, wildcard: libc::c_int);
}
extern "C" {
    pub fn rasqal_query_get_distinct(query: *mut rasqal_query) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_query_set_distinct(query: *mut rasqal_query, distinct_mode: libc::c_int);
}
extern "C" {
    pub fn rasqal_query_get_explain(query: *mut rasqal_query) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_query_set_explain(query: *mut rasqal_query, is_explain: libc::c_int);
}
extern "C" {
    pub fn rasqal_query_get_limit(query: *mut rasqal_query) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_query_set_limit(query: *mut rasqal_query, limit: libc::c_int);
}
extern "C" {
    pub fn rasqal_query_get_offset(query: *mut rasqal_query) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_query_set_offset(query: *mut rasqal_query, offset: libc::c_int);
}
extern "C" {
    pub fn rasqal_query_add_data_graph(
        query: *mut rasqal_query,
        data_graph: *mut rasqal_data_graph,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_query_add_data_graphs(
        query: *mut rasqal_query,
        data_graphs: *mut raptor_sequence,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_query_get_data_graph_sequence(query: *mut rasqal_query) -> *mut raptor_sequence;
}
extern "C" {
    pub fn rasqal_query_get_data_graph(
        query: *mut rasqal_query,
        idx: libc::c_int,
    ) -> *mut rasqal_data_graph;
}
extern "C" {
    pub fn rasqal_query_dataset_contains_named_graph(
        query: *mut rasqal_query,
        graph_uri: *mut raptor_uri,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_query_add_variable(
        query: *mut rasqal_query,
        var: *mut rasqal_variable,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_query_get_bound_variable_sequence(
        query: *mut rasqal_query,
    ) -> *mut raptor_sequence;
}
extern "C" {
    pub fn rasqal_query_get_describe_sequence(query: *mut rasqal_query) -> *mut raptor_sequence;
}
extern "C" {
    pub fn rasqal_query_get_anonymous_variable_sequence(
        query: *mut rasqal_query,
    ) -> *mut raptor_sequence;
}
extern "C" {
    pub fn rasqal_query_get_all_variable_sequence(query: *mut rasqal_query)
        -> *mut raptor_sequence;
}
extern "C" {
    pub fn rasqal_query_get_variable(
        query: *mut rasqal_query,
        idx: libc::c_int,
    ) -> *mut rasqal_variable;
}
extern "C" {
    pub fn rasqal_query_has_variable2(
        query: *mut rasqal_query,
        type_: rasqal_variable_type,
        name: *const libc::c_uchar,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_query_has_variable(
        query: *mut rasqal_query,
        name: *const libc::c_uchar,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_query_set_variable2(
        query: *mut rasqal_query,
        type_: rasqal_variable_type,
        name: *const libc::c_uchar,
        value: *mut rasqal_literal,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_query_set_variable(
        query: *mut rasqal_query,
        name: *const libc::c_uchar,
        value: *mut rasqal_literal,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_query_get_triple_sequence(query: *mut rasqal_query) -> *mut raptor_sequence;
}
extern "C" {
    pub fn rasqal_query_get_triple(
        query: *mut rasqal_query,
        idx: libc::c_int,
    ) -> *mut rasqal_triple;
}
extern "C" {
    pub fn rasqal_query_add_prefix(
        query: *mut rasqal_query,
        prefix: *mut rasqal_prefix,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_query_get_prefix_sequence(query: *mut rasqal_query) -> *mut raptor_sequence;
}
extern "C" {
    pub fn rasqal_query_get_prefix(
        query: *mut rasqal_query,
        idx: libc::c_int,
    ) -> *mut rasqal_prefix;
}
extern "C" {
    pub fn rasqal_query_get_order_conditions_sequence(
        query: *mut rasqal_query,
    ) -> *mut raptor_sequence;
}
extern "C" {
    pub fn rasqal_query_get_order_condition(
        query: *mut rasqal_query,
        idx: libc::c_int,
    ) -> *mut rasqal_expression;
}
extern "C" {
    pub fn rasqal_query_get_group_conditions_sequence(
        query: *mut rasqal_query,
    ) -> *mut raptor_sequence;
}
extern "C" {
    pub fn rasqal_query_get_group_condition(
        query: *mut rasqal_query,
        idx: libc::c_int,
    ) -> *mut rasqal_expression;
}
extern "C" {
    pub fn rasqal_query_get_having_conditions_sequence(
        query: *mut rasqal_query,
    ) -> *mut raptor_sequence;
}
extern "C" {
    pub fn rasqal_query_get_having_condition(
        query: *mut rasqal_query,
        idx: libc::c_int,
    ) -> *mut rasqal_expression;
}
extern "C" {
    pub fn rasqal_query_get_construct_triples_sequence(
        query: *mut rasqal_query,
    ) -> *mut raptor_sequence;
}
extern "C" {
    pub fn rasqal_query_get_construct_triple(
        query: *mut rasqal_query,
        idx: libc::c_int,
    ) -> *mut rasqal_triple;
}
extern "C" {
    pub fn rasqal_query_graph_pattern_visit(
        query: *mut rasqal_query,
        visit_fn: rasqal_graph_pattern_visit_fn,
        data: *mut libc::c_void,
    );
}
extern "C" {
    pub fn rasqal_query_graph_pattern_visit2(
        query: *mut rasqal_query,
        visit_fn: rasqal_graph_pattern_visit_fn,
        data: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_query_write(
        iostr: *mut raptor_iostream,
        query: *mut rasqal_query,
        format_uri: *mut raptor_uri,
        base_uri: *mut raptor_uri,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_query_get_update_operations_sequence(
        query: *mut rasqal_query,
    ) -> *mut raptor_sequence;
}
extern "C" {
    pub fn rasqal_query_get_update_operation(
        query: *mut rasqal_query,
        idx: libc::c_int,
    ) -> *mut rasqal_update_operation;
}
extern "C" {
    pub fn rasqal_query_set_store_results(
        query: *mut rasqal_query,
        store_results: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_query_get_query_graph_pattern(
        query: *mut rasqal_query,
    ) -> *mut rasqal_graph_pattern;
}
extern "C" {
    pub fn rasqal_query_get_graph_pattern_sequence(
        query: *mut rasqal_query,
    ) -> *mut raptor_sequence;
}
extern "C" {
    pub fn rasqal_query_get_graph_pattern(
        query: *mut rasqal_query,
        idx: libc::c_int,
    ) -> *mut rasqal_graph_pattern;
}
extern "C" {
    pub fn rasqal_graph_pattern_add_sub_graph_pattern(
        graph_pattern: *mut rasqal_graph_pattern,
        sub_graph_pattern: *mut rasqal_graph_pattern,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_graph_pattern_get_triple(
        graph_pattern: *mut rasqal_graph_pattern,
        idx: libc::c_int,
    ) -> *mut rasqal_triple;
}
extern "C" {
    pub fn rasqal_graph_pattern_get_sub_graph_pattern_sequence(
        graph_pattern: *mut rasqal_graph_pattern,
    ) -> *mut raptor_sequence;
}
extern "C" {
    pub fn rasqal_graph_pattern_get_sub_graph_pattern(
        graph_pattern: *mut rasqal_graph_pattern,
        idx: libc::c_int,
    ) -> *mut rasqal_graph_pattern;
}
extern "C" {
    pub fn rasqal_graph_pattern_get_operator(
        graph_pattern: *mut rasqal_graph_pattern,
    ) -> rasqal_graph_pattern_operator;
}
extern "C" {
    pub fn rasqal_graph_pattern_operator_as_string(
        op: rasqal_graph_pattern_operator,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn rasqal_graph_pattern_print(gp: *mut rasqal_graph_pattern, fh: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_graph_pattern_set_filter_expression(
        gp: *mut rasqal_graph_pattern,
        expr: *mut rasqal_expression,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_graph_pattern_get_filter_expression(
        gp: *mut rasqal_graph_pattern,
    ) -> *mut rasqal_expression;
}
extern "C" {
    pub fn rasqal_graph_pattern_visit(
        query: *mut rasqal_query,
        gp: *mut rasqal_graph_pattern,
        fn_: rasqal_graph_pattern_visit_fn,
        user_data: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_graph_pattern_get_index(gp: *mut rasqal_graph_pattern) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_graph_pattern_variable_bound_in(
        gp: *mut rasqal_graph_pattern,
        v: *mut rasqal_variable,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_graph_pattern_get_origin(
        graph_pattern: *mut rasqal_graph_pattern,
    ) -> *mut rasqal_literal;
}
extern "C" {
    pub fn rasqal_graph_pattern_get_variable(
        graph_pattern: *mut rasqal_graph_pattern,
    ) -> *mut rasqal_variable;
}
extern "C" {
    pub fn rasqal_graph_pattern_get_service(
        graph_pattern: *mut rasqal_graph_pattern,
    ) -> *mut rasqal_literal;
}
extern "C" {
    pub fn rasqal_graph_pattern_get_flattened_triples(
        query: *mut rasqal_query,
        graph_pattern: *mut rasqal_graph_pattern,
    ) -> *mut raptor_sequence;
}
extern "C" {
    pub fn rasqal_graph_pattern_get_triples(
        query: *mut rasqal_query,
        graph_pattern: *mut rasqal_graph_pattern,
    ) -> *mut raptor_sequence;
}
extern "C" {
    pub fn rasqal_query_verb_as_string(verb: rasqal_query_verb) -> *const libc::c_char;
}
extern "C" {
    pub fn rasqal_query_print(query: *mut rasqal_query, fh: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_query_prepare(
        query: *mut rasqal_query,
        query_string: *const libc::c_uchar,
        base_uri: *mut raptor_uri,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_query_execute(query: *mut rasqal_query) -> *mut rasqal_query_results;
}
extern "C" {
    pub fn rasqal_query_get_user_data(query: *mut rasqal_query) -> *mut libc::c_void;
}
extern "C" {
    pub fn rasqal_query_set_user_data(query: *mut rasqal_query, user_data: *mut libc::c_void);
}
extern "C" {
    pub fn rasqal_query_get_bindings_variables_sequence(
        query: *mut rasqal_query,
    ) -> *mut raptor_sequence;
}
extern "C" {
    pub fn rasqal_query_get_bindings_variable(
        query: *mut rasqal_query,
        idx: libc::c_int,
    ) -> *mut rasqal_variable;
}
extern "C" {
    pub fn rasqal_query_get_bindings_rows_sequence(
        query: *mut rasqal_query,
    ) -> *mut raptor_sequence;
}
extern "C" {
    pub fn rasqal_query_get_bindings_row(
        query: *mut rasqal_query,
        idx: libc::c_int,
    ) -> *mut rasqal_row;
}
extern "C" {
    pub fn rasqal_query_get_result_type(query: *mut rasqal_query) -> rasqal_query_results_type;
}
extern "C" {
    pub fn rasqal_new_query_results2(
        world: *mut rasqal_world,
        query: *mut rasqal_query,
        type_: rasqal_query_results_type,
    ) -> *mut rasqal_query_results;
}
extern "C" {
    pub fn rasqal_new_query_results(
        world: *mut rasqal_world,
        query: *mut rasqal_query,
        type_: rasqal_query_results_type,
        vars_table: *mut rasqal_variables_table,
    ) -> *mut rasqal_query_results;
}
extern "C" {
    pub fn rasqal_new_query_results_from_string(
        world: *mut rasqal_world,
        type_: rasqal_query_results_type,
        base_uri: *mut raptor_uri,
        string: *const libc::c_char,
        string_len: usize,
    ) -> *mut rasqal_query_results;
}
extern "C" {
    pub fn rasqal_free_query_results(query_results: *mut rasqal_query_results);
}
extern "C" {
    pub fn rasqal_query_results_get_query(
        query_results: *mut rasqal_query_results,
    ) -> *mut rasqal_query;
}
extern "C" {
    pub fn rasqal_query_results_get_type(
        query_results: *mut rasqal_query_results,
    ) -> rasqal_query_results_type;
}
extern "C" {
    pub fn rasqal_query_results_type_label(type_: rasqal_query_results_type)
        -> *const libc::c_char;
}
extern "C" {
    pub fn rasqal_query_results_is_bindings(
        query_results: *mut rasqal_query_results,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_query_results_get_count(query_results: *mut rasqal_query_results) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_query_results_next(query_results: *mut rasqal_query_results) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_query_results_finished(query_results: *mut rasqal_query_results) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_query_results_get_bindings(
        query_results: *mut rasqal_query_results,
        names: *mut *mut *const libc::c_uchar,
        values: *mut *mut *mut rasqal_literal,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_query_results_get_binding_value(
        query_results: *mut rasqal_query_results,
        offset: libc::c_int,
    ) -> *mut rasqal_literal;
}
extern "C" {
    pub fn rasqal_query_results_get_binding_name(
        query_results: *mut rasqal_query_results,
        offset: libc::c_int,
    ) -> *const libc::c_uchar;
}
extern "C" {
    pub fn rasqal_query_results_get_binding_value_by_name(
        query_results: *mut rasqal_query_results,
        name: *const libc::c_uchar,
    ) -> *mut rasqal_literal;
}
extern "C" {
    pub fn rasqal_query_results_get_bindings_count(
        query_results: *mut rasqal_query_results,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_query_results_add_row(
        query_results: *mut rasqal_query_results,
        row: *mut rasqal_row,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_query_results_get_row_by_offset(
        query_results: *mut rasqal_query_results,
        result_offset: libc::c_int,
    ) -> *mut rasqal_row;
}
extern "C" {
    pub fn rasqal_query_results_is_boolean(query_results: *mut rasqal_query_results)
        -> libc::c_int;
}
extern "C" {
    pub fn rasqal_query_results_get_boolean(
        query_results: *mut rasqal_query_results,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_query_results_is_graph(query_results: *mut rasqal_query_results) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_query_results_get_triple(
        query_results: *mut rasqal_query_results,
    ) -> *mut raptor_statement;
}
extern "C" {
    pub fn rasqal_query_results_next_triple(
        query_results: *mut rasqal_query_results,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_query_results_is_syntax(query_results: *mut rasqal_query_results) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_query_results_write(
        iostr: *mut raptor_iostream,
        results: *mut rasqal_query_results,
        name: *const libc::c_char,
        mime_type: *const libc::c_char,
        format_uri: *mut raptor_uri,
        base_uri: *mut raptor_uri,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_query_results_read(
        iostr: *mut raptor_iostream,
        results: *mut rasqal_query_results,
        name: *const libc::c_char,
        mime_type: *const libc::c_char,
        format_uri: *mut raptor_uri,
        base_uri: *mut raptor_uri,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_query_results_rewind(query_results: *mut rasqal_query_results) -> libc::c_int;
}
pub const rasqal_query_results_format_flags_RASQAL_QUERY_RESULTS_FORMAT_FLAG_READER:
    rasqal_query_results_format_flags = 1;
pub const rasqal_query_results_format_flags_RASQAL_QUERY_RESULTS_FORMAT_FLAG_WRITER:
    rasqal_query_results_format_flags = 2;
/// rasqal_query_results_format_flags:
/// @RASQAL_QUERY_RESULTS_FORMAT_FLAG_READER: format can be read.
/// @RASQAL_QUERY_RESULTS_FORMAT_FLAG_WRITER: format can be written.
///
/// Bitflags for rasqal_query_results_formats_check() to find formats with features.
pub type rasqal_query_results_format_flags = u32;
extern "C" {
    pub fn rasqal_query_results_formats_check2(
        world: *mut rasqal_world,
        name: *const libc::c_char,
        uri: *mut raptor_uri,
        mime_type: *const libc::c_char,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_query_results_formats_check(
        world: *mut rasqal_world,
        name: *const libc::c_char,
        uri: *mut raptor_uri,
        mime_type: *const libc::c_char,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_new_query_results_formatter(
        world: *mut rasqal_world,
        name: *const libc::c_char,
        mime_type: *const libc::c_char,
        format_uri: *mut raptor_uri,
    ) -> *mut rasqal_query_results_formatter;
}
extern "C" {
    pub fn rasqal_new_query_results_formatter_for_content(
        world: *mut rasqal_world,
        uri: *mut raptor_uri,
        mime_type: *const libc::c_char,
        buffer: *const libc::c_uchar,
        len: usize,
        identifier: *const libc::c_uchar,
    ) -> *mut rasqal_query_results_formatter;
}
extern "C" {
    pub fn rasqal_free_query_results_formatter(formatter: *mut rasqal_query_results_formatter);
}
extern "C" {
    pub fn rasqal_query_results_formatter_write(
        iostr: *mut raptor_iostream,
        formatter: *mut rasqal_query_results_formatter,
        results: *mut rasqal_query_results,
        base_uri: *mut raptor_uri,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_query_results_formatter_read(
        world: *mut rasqal_world,
        iostr: *mut raptor_iostream,
        formatter: *mut rasqal_query_results_formatter,
        results: *mut rasqal_query_results,
        base_uri: *mut raptor_uri,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_query_iostream_write_escaped_counted_string(
        query: *mut rasqal_query,
        iostr: *mut raptor_iostream,
        string: *const libc::c_uchar,
        len: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_query_escape_counted_string(
        query: *mut rasqal_query,
        string: *const libc::c_uchar,
        len: usize,
        output_len_p: *mut usize,
    ) -> *mut libc::c_uchar;
}
extern "C" {
    pub fn rasqal_new_data_graph_from_uri(
        world: *mut rasqal_world,
        uri: *mut raptor_uri,
        name_uri: *mut raptor_uri,
        flags: libc::c_uint,
        format_type: *const libc::c_char,
        format_name: *const libc::c_char,
        format_uri: *mut raptor_uri,
    ) -> *mut rasqal_data_graph;
}
extern "C" {
    pub fn rasqal_new_data_graph_from_iostream(
        world: *mut rasqal_world,
        iostr: *mut raptor_iostream,
        base_uri: *mut raptor_uri,
        name_uri: *mut raptor_uri,
        flags: libc::c_uint,
        format_type: *const libc::c_char,
        format_name: *const libc::c_char,
        format_uri: *mut raptor_uri,
    ) -> *mut rasqal_data_graph;
}
extern "C" {
    pub fn rasqal_new_data_graph_from_data_graph(
        dg: *mut rasqal_data_graph,
    ) -> *mut rasqal_data_graph;
}
extern "C" {
    pub fn rasqal_free_data_graph(dg: *mut rasqal_data_graph);
}
extern "C" {
    pub fn rasqal_data_graph_print(dg: *mut rasqal_data_graph, fh: *mut FILE) -> libc::c_int;
}
pub const rasqal_compare_flags_RASQAL_COMPARE_NOCASE: rasqal_compare_flags = 1;
pub const rasqal_compare_flags_RASQAL_COMPARE_XQUERY: rasqal_compare_flags = 2;
pub const rasqal_compare_flags_RASQAL_COMPARE_RDF: rasqal_compare_flags = 4;
pub const rasqal_compare_flags_RASQAL_COMPARE_URI: rasqal_compare_flags = 8;
pub const rasqal_compare_flags_RASQAL_COMPARE_SAMETERM: rasqal_compare_flags = 16;
/// rasqal_compare_flags:
/// @RASQAL_COMPARE_NOCASE: String comparisons are case independent.
/// @RASQAL_COMPARE_XQUERY: XQuery comparsion rules apply.
/// @RASQAL_COMPARE_RDF:    RDF Term comparsion rules apply.
/// @RASQAL_COMPARE_URI:    Allow comparison of URIs and allow strings to have a boolean value (unused; was for RDQL)
/// @RASQAL_COMPARE_SAMETERM: SPARQL sameTerm() builtin rules apply.
///
/// Flags for rasqal_expression_evaluate(), rasqal_literal_compare() or
/// rasqal_literal_as_string_flags()
pub type rasqal_compare_flags = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rasqal_random_s {
    _unused: [u8; 0],
}
/// rasqal_random:
///
/// Internal
pub type rasqal_random = rasqal_random_s;
/// rasqal_evaluation_context:
/// @world: rasqal world
/// @base_uri: base URI of expression context (or NULL)
/// @locator: locator or NULL
/// @flags: expression comparison flags
/// @seed: random seeed
/// @random: random number generator object
///
/// A context for evaluating an expression such as with
/// rasqal_expression_evaluate2()
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rasqal_evaluation_context {
    pub world: *mut rasqal_world,
    pub base_uri: *mut raptor_uri,
    pub locator: *mut raptor_locator,
    pub flags: libc::c_int,
    pub seed: libc::c_uint,
    pub random: *mut rasqal_random,
}
#[test]
fn bindgen_test_layout_rasqal_evaluation_context() {
    assert_eq!(
        ::std::mem::size_of::<rasqal_evaluation_context>(),
        40usize,
        concat!("Size of: ", stringify!(rasqal_evaluation_context))
    );
    assert_eq!(
        ::std::mem::align_of::<rasqal_evaluation_context>(),
        8usize,
        concat!("Alignment of ", stringify!(rasqal_evaluation_context))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_evaluation_context>())).world as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_evaluation_context),
            "::",
            stringify!(world)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rasqal_evaluation_context>())).base_uri as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_evaluation_context),
            "::",
            stringify!(base_uri)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rasqal_evaluation_context>())).locator as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_evaluation_context),
            "::",
            stringify!(locator)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_evaluation_context>())).flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_evaluation_context),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_evaluation_context>())).seed as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_evaluation_context),
            "::",
            stringify!(seed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rasqal_evaluation_context>())).random as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_evaluation_context),
            "::",
            stringify!(random)
        )
    );
}
extern "C" {
    pub fn rasqal_new_0op_expression(
        world: *mut rasqal_world,
        op: rasqal_op,
    ) -> *mut rasqal_expression;
}
extern "C" {
    pub fn rasqal_new_1op_expression(
        world: *mut rasqal_world,
        op: rasqal_op,
        arg: *mut rasqal_expression,
    ) -> *mut rasqal_expression;
}
extern "C" {
    pub fn rasqal_new_2op_expression(
        world: *mut rasqal_world,
        op: rasqal_op,
        arg1: *mut rasqal_expression,
        arg2: *mut rasqal_expression,
    ) -> *mut rasqal_expression;
}
extern "C" {
    pub fn rasqal_new_3op_expression(
        world: *mut rasqal_world,
        op: rasqal_op,
        arg1: *mut rasqal_expression,
        arg2: *mut rasqal_expression,
        arg3: *mut rasqal_expression,
    ) -> *mut rasqal_expression;
}
extern "C" {
    pub fn rasqal_new_4op_expression(
        world: *mut rasqal_world,
        op: rasqal_op,
        arg1: *mut rasqal_expression,
        arg2: *mut rasqal_expression,
        arg3: *mut rasqal_expression,
        arg4: *mut rasqal_expression,
    ) -> *mut rasqal_expression;
}
extern "C" {
    pub fn rasqal_new_string_op_expression(
        world: *mut rasqal_world,
        op: rasqal_op,
        arg1: *mut rasqal_expression,
        literal: *mut rasqal_literal,
    ) -> *mut rasqal_expression;
}
extern "C" {
    pub fn rasqal_new_literal_expression(
        world: *mut rasqal_world,
        literal: *mut rasqal_literal,
    ) -> *mut rasqal_expression;
}
extern "C" {
    pub fn rasqal_new_function_expression(
        world: *mut rasqal_world,
        name: *mut raptor_uri,
        args: *mut raptor_sequence,
        params: *mut raptor_sequence,
        flags: libc::c_uint,
    ) -> *mut rasqal_expression;
}
extern "C" {
    pub fn rasqal_new_aggregate_function_expression(
        world: *mut rasqal_world,
        op: rasqal_op,
        arg1: *mut rasqal_expression,
        params: *mut raptor_sequence,
        flags: libc::c_uint,
    ) -> *mut rasqal_expression;
}
extern "C" {
    pub fn rasqal_new_cast_expression(
        world: *mut rasqal_world,
        name: *mut raptor_uri,
        value: *mut rasqal_expression,
    ) -> *mut rasqal_expression;
}
extern "C" {
    pub fn rasqal_new_expr_seq_expression(
        world: *mut rasqal_world,
        op: rasqal_op,
        args: *mut raptor_sequence,
    ) -> *mut rasqal_expression;
}
extern "C" {
    pub fn rasqal_new_set_expression(
        world: *mut rasqal_world,
        op: rasqal_op,
        arg1: *mut rasqal_expression,
        args: *mut raptor_sequence,
    ) -> *mut rasqal_expression;
}
extern "C" {
    pub fn rasqal_new_group_concat_expression(
        world: *mut rasqal_world,
        flags: libc::c_uint,
        args: *mut raptor_sequence,
        separator: *mut rasqal_literal,
    ) -> *mut rasqal_expression;
}
extern "C" {
    pub fn rasqal_new_expression_from_expression(
        e: *mut rasqal_expression,
    ) -> *mut rasqal_expression;
}
extern "C" {
    pub fn rasqal_free_expression(e: *mut rasqal_expression);
}
extern "C" {
    pub fn rasqal_expression_print_op(e: *mut rasqal_expression, fh: *mut FILE);
}
extern "C" {
    pub fn rasqal_expression_print(e: *mut rasqal_expression, fh: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_expression_evaluate(
        world: *mut rasqal_world,
        locator: *mut raptor_locator,
        e: *mut rasqal_expression,
        flags: libc::c_int,
    ) -> *mut rasqal_literal;
}
extern "C" {
    pub fn rasqal_expression_evaluate2(
        e: *mut rasqal_expression,
        eval_context: *mut rasqal_evaluation_context,
        error_p: *mut libc::c_int,
    ) -> *mut rasqal_literal;
}
extern "C" {
    pub fn rasqal_expression_op_label(op: rasqal_op) -> *const libc::c_char;
}
extern "C" {
    pub fn rasqal_expression_compare(
        e1: *mut rasqal_expression,
        e2: *mut rasqal_expression,
        flags: libc::c_int,
        error_p: *mut libc::c_int,
    ) -> libc::c_int;
}
/// rasqal_expression_visit_fn:
/// @user_data: user data passed in with rasqal_expression_visit()
/// @e: current expression
///
/// User function to visit an expression and operate on it with
/// rasqal_expression_visit()
///
/// Return value: non-0 to truncate the visit
pub type rasqal_expression_visit_fn = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut libc::c_void, e: *mut rasqal_expression) -> libc::c_int,
>;
extern "C" {
    pub fn rasqal_expression_visit(
        e: *mut rasqal_expression,
        fn_: rasqal_expression_visit_fn,
        user_data: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_new_evaluation_context(
        world: *mut rasqal_world,
        locator: *mut raptor_locator,
        flags: libc::c_int,
    ) -> *mut rasqal_evaluation_context;
}
extern "C" {
    pub fn rasqal_free_evaluation_context(eval_context: *mut rasqal_evaluation_context);
}
extern "C" {
    pub fn rasqal_evaluation_context_set_base_uri(
        eval_context: *mut rasqal_evaluation_context,
        base_uri: *mut raptor_uri,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_evaluation_context_set_rand_seed(
        eval_context: *mut rasqal_evaluation_context,
        seed: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_new_integer_literal(
        world: *mut rasqal_world,
        type_: rasqal_literal_type,
        integer: libc::c_int,
    ) -> *mut rasqal_literal;
}
extern "C" {
    pub fn rasqal_new_numeric_literal_from_long(
        world: *mut rasqal_world,
        type_: rasqal_literal_type,
        value: libc::c_long,
    ) -> *mut rasqal_literal;
}
extern "C" {
    pub fn rasqal_new_typed_literal(
        world: *mut rasqal_world,
        type_: rasqal_literal_type,
        string: *const libc::c_uchar,
    ) -> *mut rasqal_literal;
}
extern "C" {
    pub fn rasqal_new_double_literal(world: *mut rasqal_world, d: f64) -> *mut rasqal_literal;
}
extern "C" {
    pub fn rasqal_new_floating_literal(
        world: *mut rasqal_world,
        type_: rasqal_literal_type,
        d: f64,
    ) -> *mut rasqal_literal;
}
extern "C" {
    pub fn rasqal_new_float_literal(world: *mut rasqal_world, f: f32) -> *mut rasqal_literal;
}
extern "C" {
    pub fn rasqal_new_uri_literal(
        world: *mut rasqal_world,
        uri: *mut raptor_uri,
    ) -> *mut rasqal_literal;
}
extern "C" {
    pub fn rasqal_new_pattern_literal(
        world: *mut rasqal_world,
        pattern: *const libc::c_uchar,
        flags: *const libc::c_char,
    ) -> *mut rasqal_literal;
}
extern "C" {
    pub fn rasqal_new_string_literal(
        world: *mut rasqal_world,
        string: *const libc::c_uchar,
        language: *const libc::c_char,
        datatype: *mut raptor_uri,
        datatype_qname: *const libc::c_uchar,
    ) -> *mut rasqal_literal;
}
extern "C" {
    pub fn rasqal_new_simple_literal(
        world: *mut rasqal_world,
        type_: rasqal_literal_type,
        string: *const libc::c_uchar,
    ) -> *mut rasqal_literal;
}
extern "C" {
    pub fn rasqal_new_boolean_literal(
        world: *mut rasqal_world,
        value: libc::c_int,
    ) -> *mut rasqal_literal;
}
extern "C" {
    pub fn rasqal_new_variable_literal(
        world: *mut rasqal_world,
        variable: *mut rasqal_variable,
    ) -> *mut rasqal_literal;
}
extern "C" {
    pub fn rasqal_new_decimal_literal(
        world: *mut rasqal_world,
        string: *const libc::c_uchar,
    ) -> *mut rasqal_literal;
}
extern "C" {
    pub fn rasqal_new_decimal_literal_from_decimal(
        world: *mut rasqal_world,
        string: *const libc::c_uchar,
        decimal: *mut rasqal_xsd_decimal,
    ) -> *mut rasqal_literal;
}
extern "C" {
    pub fn rasqal_new_datetime_literal_from_datetime(
        world: *mut rasqal_world,
        dt: *mut rasqal_xsd_datetime,
    ) -> *mut rasqal_literal;
}
extern "C" {
    pub fn rasqal_new_literal_from_literal(l: *mut rasqal_literal) -> *mut rasqal_literal;
}
extern "C" {
    pub fn rasqal_free_literal(l: *mut rasqal_literal);
}
extern "C" {
    pub fn rasqal_literal_print(l: *mut rasqal_literal, fh: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_literal_type_label(type_: rasqal_literal_type) -> *const libc::c_char;
}
extern "C" {
    pub fn rasqal_literal_print_type(l: *mut rasqal_literal, fh: *mut FILE);
}
extern "C" {
    pub fn rasqal_literal_as_variable(l: *mut rasqal_literal) -> *mut rasqal_variable;
}
extern "C" {
    pub fn rasqal_literal_as_counted_string(
        l: *mut rasqal_literal,
        len_p: *mut usize,
        flags: libc::c_int,
        error_p: *mut libc::c_int,
    ) -> *const libc::c_uchar;
}
extern "C" {
    pub fn rasqal_literal_as_string(l: *mut rasqal_literal) -> *const libc::c_uchar;
}
extern "C" {
    pub fn rasqal_literal_as_string_flags(
        l: *mut rasqal_literal,
        flags: libc::c_int,
        error_p: *mut libc::c_int,
    ) -> *const libc::c_uchar;
}
extern "C" {
    pub fn rasqal_literal_as_node(l: *mut rasqal_literal) -> *mut rasqal_literal;
}
extern "C" {
    pub fn rasqal_literal_datatype(l: *mut rasqal_literal) -> *mut raptor_uri;
}
extern "C" {
    pub fn rasqal_literal_value(l: *mut rasqal_literal) -> *mut rasqal_literal;
}
extern "C" {
    pub fn rasqal_literal_compare(
        l1: *mut rasqal_literal,
        l2: *mut rasqal_literal,
        flags: libc::c_int,
        error_p: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_literal_equals(l1: *mut rasqal_literal, l2: *mut rasqal_literal) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_literal_same_term(
        l1: *mut rasqal_literal,
        l2: *mut rasqal_literal,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_literal_get_rdf_term_type(l: *mut rasqal_literal) -> rasqal_literal_type;
}
extern "C" {
    pub fn rasqal_literal_get_type(l: *mut rasqal_literal) -> rasqal_literal_type;
}
extern "C" {
    pub fn rasqal_literal_get_language(l: *mut rasqal_literal) -> *mut libc::c_char;
}
extern "C" {
    pub fn rasqal_literal_is_rdf_literal(l: *mut rasqal_literal) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_new_prefix(
        world: *mut rasqal_world,
        prefix: *const libc::c_uchar,
        uri: *mut raptor_uri,
    ) -> *mut rasqal_prefix;
}
extern "C" {
    pub fn rasqal_free_prefix(p: *mut rasqal_prefix);
}
extern "C" {
    pub fn rasqal_prefix_print(p: *mut rasqal_prefix, fh: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_new_row_for_size(world: *mut rasqal_world, size: libc::c_int) -> *mut rasqal_row;
}
extern "C" {
    pub fn rasqal_free_row(row: *mut rasqal_row);
}
extern "C" {
    pub fn rasqal_row_set_value_at(
        row: *mut rasqal_row,
        offset: libc::c_int,
        value: *mut rasqal_literal,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_new_triple(
        subject: *mut rasqal_literal,
        predicate: *mut rasqal_literal,
        object: *mut rasqal_literal,
    ) -> *mut rasqal_triple;
}
extern "C" {
    pub fn rasqal_new_triple_from_triple(t: *mut rasqal_triple) -> *mut rasqal_triple;
}
extern "C" {
    pub fn rasqal_free_triple(t: *mut rasqal_triple);
}
extern "C" {
    pub fn rasqal_triple_print(t: *mut rasqal_triple, fh: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_triple_set_origin(t: *mut rasqal_triple, l: *mut rasqal_literal);
}
extern "C" {
    pub fn rasqal_triple_get_origin(t: *mut rasqal_triple) -> *mut rasqal_literal;
}
extern "C" {
    pub fn rasqal_new_variable_from_variable(v: *mut rasqal_variable) -> *mut rasqal_variable;
}
extern "C" {
    pub fn rasqal_free_variable(v: *mut rasqal_variable);
}
extern "C" {
    pub fn rasqal_variable_print(v: *mut rasqal_variable, fh: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_variable_set_value(v: *mut rasqal_variable, l: *mut rasqal_literal);
}
extern "C" {
    pub fn rasqal_new_variables_table(world: *mut rasqal_world) -> *mut rasqal_variables_table;
}
extern "C" {
    pub fn rasqal_free_variables_table(vt: *mut rasqal_variables_table);
}
extern "C" {
    pub fn rasqal_variables_table_add(
        vt: *mut rasqal_variables_table,
        type_: rasqal_variable_type,
        name: *const libc::c_uchar,
        value: *mut rasqal_literal,
    ) -> *mut rasqal_variable;
}
extern "C" {
    pub fn rasqal_variables_table_add2(
        vt: *mut rasqal_variables_table,
        type_: rasqal_variable_type,
        name: *const libc::c_uchar,
        name_len: usize,
        value: *mut rasqal_literal,
    ) -> *mut rasqal_variable;
}
extern "C" {
    pub fn rasqal_variables_table_add_variable(
        vt: *mut rasqal_variables_table,
        variable: *mut rasqal_variable,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_variables_table_get_by_name(
        vt: *mut rasqal_variables_table,
        type_: rasqal_variable_type,
        name: *const libc::c_uchar,
    ) -> *mut rasqal_variable;
}
extern "C" {
    pub fn rasqal_variables_table_contains(
        vt: *mut rasqal_variables_table,
        type_: rasqal_variable_type,
        name: *const libc::c_uchar,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_free_memory(ptr: *mut libc::c_void);
}
extern "C" {
    pub fn rasqal_alloc_memory(size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn rasqal_calloc_memory(nmemb: usize, size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn rasqal_new_xsd_decimal(world: *mut rasqal_world) -> *mut rasqal_xsd_decimal;
}
extern "C" {
    pub fn rasqal_free_xsd_decimal(dec: *mut rasqal_xsd_decimal);
}
extern "C" {
    pub fn rasqal_xsd_decimal_set_string(
        dec: *mut rasqal_xsd_decimal,
        string: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_xsd_decimal_get_double(dec: *mut rasqal_xsd_decimal) -> f64;
}
extern "C" {
    pub fn rasqal_xsd_decimal_get_long(
        dec: *mut rasqal_xsd_decimal,
        error_p: *mut libc::c_int,
    ) -> libc::c_long;
}
extern "C" {
    pub fn rasqal_xsd_decimal_as_string(dec: *mut rasqal_xsd_decimal) -> *mut libc::c_char;
}
extern "C" {
    pub fn rasqal_xsd_decimal_as_counted_string(
        dec: *mut rasqal_xsd_decimal,
        len_p: *mut usize,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn rasqal_xsd_decimal_set_long(
        dec: *mut rasqal_xsd_decimal,
        l: libc::c_long,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_xsd_decimal_set_double(dec: *mut rasqal_xsd_decimal, d: f64) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_xsd_decimal_print(dec: *mut rasqal_xsd_decimal, stream: *mut FILE)
        -> libc::c_int;
}
extern "C" {
    pub fn rasqal_xsd_decimal_add(
        result: *mut rasqal_xsd_decimal,
        a: *mut rasqal_xsd_decimal,
        b: *mut rasqal_xsd_decimal,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_xsd_decimal_subtract(
        result: *mut rasqal_xsd_decimal,
        a: *mut rasqal_xsd_decimal,
        b: *mut rasqal_xsd_decimal,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_xsd_decimal_multiply(
        result: *mut rasqal_xsd_decimal,
        a: *mut rasqal_xsd_decimal,
        b: *mut rasqal_xsd_decimal,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_xsd_decimal_divide(
        result: *mut rasqal_xsd_decimal,
        a: *mut rasqal_xsd_decimal,
        b: *mut rasqal_xsd_decimal,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_xsd_decimal_negate(
        result: *mut rasqal_xsd_decimal,
        a: *mut rasqal_xsd_decimal,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_xsd_decimal_compare(
        a: *mut rasqal_xsd_decimal,
        b: *mut rasqal_xsd_decimal,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_xsd_decimal_equals(
        a: *mut rasqal_xsd_decimal,
        b: *mut rasqal_xsd_decimal,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_xsd_decimal_is_zero(d: *mut rasqal_xsd_decimal) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_xsd_decimal_abs(
        result: *mut rasqal_xsd_decimal,
        a: *mut rasqal_xsd_decimal,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_xsd_decimal_round(
        result: *mut rasqal_xsd_decimal,
        a: *mut rasqal_xsd_decimal,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_xsd_decimal_ceil(
        result: *mut rasqal_xsd_decimal,
        a: *mut rasqal_xsd_decimal,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_xsd_decimal_floor(
        result: *mut rasqal_xsd_decimal,
        a: *mut rasqal_xsd_decimal,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_new_xsd_date(
        world: *mut rasqal_world,
        date_string: *const libc::c_char,
    ) -> *mut rasqal_xsd_date;
}
extern "C" {
    pub fn rasqal_free_xsd_date(d: *mut rasqal_xsd_date);
}
extern "C" {
    pub fn rasqal_xsd_date_to_counted_string(
        date: *const rasqal_xsd_date,
        len_p: *mut usize,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn rasqal_xsd_date_to_string(d: *const rasqal_xsd_date) -> *mut libc::c_char;
}
extern "C" {
    pub fn rasqal_xsd_date_equals(
        d1: *const rasqal_xsd_date,
        d2: *const rasqal_xsd_date,
        incomparible_p: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_xsd_date_compare(
        d1: *const rasqal_xsd_date,
        d2: *const rasqal_xsd_date,
        incomparible_p: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_new_xsd_datetime(
        world: *mut rasqal_world,
        datetime_string: *const libc::c_char,
    ) -> *mut rasqal_xsd_datetime;
}
extern "C" {
    pub fn rasqal_new_xsd_datetime_from_unixtime(
        world: *mut rasqal_world,
        secs: time_t,
    ) -> *mut rasqal_xsd_datetime;
}
extern "C" {
    pub fn rasqal_new_xsd_datetime_from_timeval(
        world: *mut rasqal_world,
        tv: *mut timeval,
    ) -> *mut rasqal_xsd_datetime;
}
extern "C" {
    pub fn rasqal_new_xsd_datetime_from_xsd_date(
        world: *mut rasqal_world,
        date: *mut rasqal_xsd_date,
    ) -> *mut rasqal_xsd_datetime;
}
extern "C" {
    pub fn rasqal_free_xsd_datetime(dt: *mut rasqal_xsd_datetime);
}
extern "C" {
    pub fn rasqal_xsd_datetime_to_counted_string(
        dt: *const rasqal_xsd_datetime,
        len_p: *mut usize,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn rasqal_xsd_datetime_to_string(dt: *const rasqal_xsd_datetime) -> *mut libc::c_char;
}
extern "C" {
    pub fn rasqal_xsd_datetime_equals2(
        dt1: *const rasqal_xsd_datetime,
        dt2: *const rasqal_xsd_datetime,
        incomparible_p: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_xsd_datetime_equals(
        dt1: *const rasqal_xsd_datetime,
        dt2: *const rasqal_xsd_datetime,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_xsd_datetime_compare2(
        dt1: *const rasqal_xsd_datetime,
        dt2: *const rasqal_xsd_datetime,
        incomparible_p: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_xsd_datetime_compare(
        dt1: *const rasqal_xsd_datetime,
        dt2: *const rasqal_xsd_datetime,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_xsd_datetime_get_seconds_as_decimal(
        world: *mut rasqal_world,
        dt: *mut rasqal_xsd_datetime,
    ) -> *mut rasqal_xsd_decimal;
}
extern "C" {
    pub fn rasqal_xsd_datetime_set_from_timeval(
        dt: *mut rasqal_xsd_datetime,
        tv: *mut timeval,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_xsd_datetime_set_from_unixtime(
        dt: *mut rasqal_xsd_datetime,
        clock: time_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_xsd_datetime_get_as_unixtime(dt: *mut rasqal_xsd_datetime) -> time_t;
}
extern "C" {
    pub fn rasqal_xsd_datetime_get_as_timeval(dt: *mut rasqal_xsd_datetime) -> *mut timeval;
}
extern "C" {
    pub fn rasqal_xsd_datetime_get_timezone_as_counted_string(
        dt: *mut rasqal_xsd_datetime,
        len_p: *mut usize,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn rasqal_xsd_datetime_get_tz_as_counted_string(
        dt: *mut rasqal_xsd_datetime,
        len_p: *mut usize,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn rasqal_regex_replace(
        world: *mut rasqal_world,
        locator: *mut raptor_locator,
        pattern: *const libc::c_char,
        regex_flags: *const libc::c_char,
        subject: *const libc::c_char,
        subject_len: usize,
        replace: *const libc::c_char,
        replace_len: usize,
        result_len_p: *mut usize,
    ) -> *mut libc::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rasqal_service_s {
    _unused: [u8; 0],
}
/// rasqal_service:
///
/// Rasqal SPARQL Protocol Service
pub type rasqal_service = rasqal_service_s;
extern "C" {
    pub fn rasqal_new_service(
        world: *mut rasqal_world,
        service_uri: *mut raptor_uri,
        query_string: *const libc::c_uchar,
        data_graphs: *mut raptor_sequence,
    ) -> *mut rasqal_service;
}
extern "C" {
    pub fn rasqal_free_service(svc: *mut rasqal_service);
}
extern "C" {
    pub fn rasqal_service_execute(svc: *mut rasqal_service) -> *mut rasqal_query_results;
}
extern "C" {
    pub fn rasqal_service_set_www(svc: *mut rasqal_service, www: *mut raptor_www) -> libc::c_int;
}
extern "C" {
    pub fn rasqal_service_set_format(
        svc: *mut rasqal_service,
        format: *const libc::c_char,
    ) -> libc::c_int;
}
pub const rasqal_triple_parts_RASQAL_TRIPLE_NONE: rasqal_triple_parts = 0;
pub const rasqal_triple_parts_RASQAL_TRIPLE_SUBJECT: rasqal_triple_parts = 1;
pub const rasqal_triple_parts_RASQAL_TRIPLE_PREDICATE: rasqal_triple_parts = 2;
pub const rasqal_triple_parts_RASQAL_TRIPLE_OBJECT: rasqal_triple_parts = 4;
pub const rasqal_triple_parts_RASQAL_TRIPLE_ORIGIN: rasqal_triple_parts = 8;
pub const rasqal_triple_parts_RASQAL_TRIPLE_GRAPH: rasqal_triple_parts = 8;
pub const rasqal_triple_parts_RASQAL_TRIPLE_SPO: rasqal_triple_parts = 7;
pub const rasqal_triple_parts_RASQAL_TRIPLE_SPOG: rasqal_triple_parts = 15;
/// rasqal_triple_parts:
/// @RASQAL_TRIPLE_NONE: no parts
/// @RASQAL_TRIPLE_SUBJECT: Subject present in a triple.
/// @RASQAL_TRIPLE_PREDICATE: Predicate present in a triple.
/// @RASQAL_TRIPLE_OBJECT: Object present in a triple.
/// @RASQAL_TRIPLE_ORIGIN: Origin/graph present in a triple.
/// @RASQAL_TRIPLE_GRAPH:  Alias for RASQAL_TRIPLE_ORIGIN
/// @RASQAL_TRIPLE_SPO: Subject, Predicate and Object present in a triple.
/// @RASQAL_TRIPLE_SPOG: Subject, Predicate, Object, Graph present in a triple.
///
/// Flags for parts of a triple.
pub type rasqal_triple_parts = u32;
/// rasqal_triples_match:
/// @world: rasqal_world object
/// @user_data: User data pointer for factory methods.
/// @bind_match: The [4]array (s,p,o,origin) bindings against the current triple match only touching triple parts given. Returns parts that were bound or 0 on failure.
/// @next_match: Move to next match.
/// @is_end: Check for end of triple match - return non-0 if is end.
/// @finish: Finish triples match and destroy any allocated memory.
/// @is_exact: non-0 if triple to match is all literal constants
/// @finished: >0 if the match has finished
///
/// Triples match structure as initialised by #rasqal_triples_source
/// method init_triples_match.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rasqal_triples_match_s {
    pub world: *mut rasqal_world,
    pub user_data: *mut libc::c_void,
    pub bind_match: ::std::option::Option<
        unsafe extern "C" fn(
            rtm: *mut rasqal_triples_match_s,
            user_data: *mut libc::c_void,
            bindings: *mut *mut rasqal_variable,
            parts: rasqal_triple_parts,
        ) -> rasqal_triple_parts,
    >,
    pub next_match: ::std::option::Option<
        unsafe extern "C" fn(rtm: *mut rasqal_triples_match_s, user_data: *mut libc::c_void),
    >,
    pub is_end: ::std::option::Option<
        unsafe extern "C" fn(rtm: *mut rasqal_triples_match_s, user_data: *mut libc::c_void)
            -> libc::c_int,
    >,
    pub finish: ::std::option::Option<
        unsafe extern "C" fn(rtm: *mut rasqal_triples_match_s, user_data: *mut libc::c_void),
    >,
    pub is_exact: libc::c_int,
    pub finished: libc::c_int,
}
#[test]
fn bindgen_test_layout_rasqal_triples_match_s() {
    assert_eq!(
        ::std::mem::size_of::<rasqal_triples_match_s>(),
        56usize,
        concat!("Size of: ", stringify!(rasqal_triples_match_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rasqal_triples_match_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rasqal_triples_match_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_triples_match_s>())).world as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_triples_match_s),
            "::",
            stringify!(world)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rasqal_triples_match_s>())).user_data as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_triples_match_s),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rasqal_triples_match_s>())).bind_match as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_triples_match_s),
            "::",
            stringify!(bind_match)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rasqal_triples_match_s>())).next_match as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_triples_match_s),
            "::",
            stringify!(next_match)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_triples_match_s>())).is_end as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_triples_match_s),
            "::",
            stringify!(is_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_triples_match_s>())).finish as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_triples_match_s),
            "::",
            stringify!(finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_triples_match_s>())).is_exact as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_triples_match_s),
            "::",
            stringify!(is_exact)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_triples_match_s>())).finished as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_triples_match_s),
            "::",
            stringify!(finished)
        )
    );
}
pub type rasqal_triples_match = rasqal_triples_match_s;
/// rasqal_triple_meta:
/// @bindings: Variable bindings for this triple+origin to set.
/// @triples_match: The matcher that is setting these bindings.
/// @context: Context data used by the matcher.
/// @parts: Bitmask of #rasqal_triple_parts flags describing the parts of the triple pattern that will bind to variables.  There may also be variables mentioned that are bound in other triple patterns even if @parts is 0.
/// @is_exact: unused
/// @executed: unused
///
/// Metadata for triple pattern matching for one triple pattern.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rasqal_triple_meta {
    pub bindings: [*mut rasqal_variable; 4usize],
    pub triples_match: *mut rasqal_triples_match,
    pub context: *mut libc::c_void,
    pub parts: rasqal_triple_parts,
    pub is_exact: libc::c_int,
    pub executed: libc::c_int,
}
#[test]
fn bindgen_test_layout_rasqal_triple_meta() {
    assert_eq!(
        ::std::mem::size_of::<rasqal_triple_meta>(),
        64usize,
        concat!("Size of: ", stringify!(rasqal_triple_meta))
    );
    assert_eq!(
        ::std::mem::align_of::<rasqal_triple_meta>(),
        8usize,
        concat!("Alignment of ", stringify!(rasqal_triple_meta))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_triple_meta>())).bindings as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_triple_meta),
            "::",
            stringify!(bindings)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rasqal_triple_meta>())).triples_match as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_triple_meta),
            "::",
            stringify!(triples_match)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_triple_meta>())).context as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_triple_meta),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_triple_meta>())).parts as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_triple_meta),
            "::",
            stringify!(parts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_triple_meta>())).is_exact as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_triple_meta),
            "::",
            stringify!(is_exact)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_triple_meta>())).executed as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_triple_meta),
            "::",
            stringify!(executed)
        )
    );
}
pub const rasqal_triples_source_feature_RASQAL_TRIPLES_SOURCE_FEATURE_NONE:
    rasqal_triples_source_feature = 0;
pub const rasqal_triples_source_feature_RASQAL_TRIPLES_SOURCE_FEATURE_IOSTREAM_DATA_GRAPH:
    rasqal_triples_source_feature = 1;
/// rasqal_triples_source_feature:
/// @RASQAL_TRIPLES_SOURCE_FEATURE_NONE: No feature
/// @RASQAL_TRIPLES_SOURCE_FEATURE_IOSTREAM_DATA_GRAPH: Support raptor_iostream data graphs
///
/// Optional features that may be supported by a triple source factory
pub type rasqal_triples_source_feature = u32;
/// rasqal_triples_source:
/// @version: API version - only V1 is defined for now
/// @query: Source for this query.
/// @user_data: Context user data passed into the factory methods.
/// @init_triples_match: Factory method to initalise a new #rasqal_triples_match.
/// @triple_present: Factory method to return presence or absence of a complete triple.
/// @free_triples_source: Factory method to deallocate resources.
/// @support_feature: Factory method to test support for a feature, returning non-0 if supported
///
/// Triples source as initialised by a #rasqal_triples_source_factory.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rasqal_triples_source_s {
    pub version: libc::c_int,
    pub query: *mut rasqal_query,
    pub user_data: *mut libc::c_void,
    pub init_triples_match: ::std::option::Option<
        unsafe extern "C" fn(
            rtm: *mut rasqal_triples_match,
            rts: *mut rasqal_triples_source_s,
            user_data: *mut libc::c_void,
            m: *mut rasqal_triple_meta,
            t: *mut rasqal_triple,
        ) -> libc::c_int,
    >,
    pub triple_present: ::std::option::Option<
        unsafe extern "C" fn(
            rts: *mut rasqal_triples_source_s,
            user_data: *mut libc::c_void,
            t: *mut rasqal_triple,
        ) -> libc::c_int,
    >,
    pub free_triples_source:
        ::std::option::Option<unsafe extern "C" fn(user_data: *mut libc::c_void)>,
    pub support_feature: ::std::option::Option<
        unsafe extern "C" fn(user_data: *mut libc::c_void, feature: rasqal_triples_source_feature)
            -> libc::c_int,
    >,
}
#[test]
fn bindgen_test_layout_rasqal_triples_source_s() {
    assert_eq!(
        ::std::mem::size_of::<rasqal_triples_source_s>(),
        56usize,
        concat!("Size of: ", stringify!(rasqal_triples_source_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rasqal_triples_source_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rasqal_triples_source_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_triples_source_s>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_triples_source_s),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasqal_triples_source_s>())).query as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_triples_source_s),
            "::",
            stringify!(query)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rasqal_triples_source_s>())).user_data as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_triples_source_s),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rasqal_triples_source_s>())).init_triples_match as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_triples_source_s),
            "::",
            stringify!(init_triples_match)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rasqal_triples_source_s>())).triple_present as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_triples_source_s),
            "::",
            stringify!(triple_present)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rasqal_triples_source_s>())).free_triples_source as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_triples_source_s),
            "::",
            stringify!(free_triples_source)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rasqal_triples_source_s>())).support_feature as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_triples_source_s),
            "::",
            stringify!(support_feature)
        )
    );
}
pub type rasqal_triples_source = rasqal_triples_source_s;
/// rasqal_triples_error_handler:
/// @query: query object
/// @locator: error locator (or NULL)
/// @message: error message
///
/// Triples source factory error handler callback.
pub type rasqal_triples_error_handler = ::std::option::Option<
    unsafe extern "C" fn(
        query: *mut rasqal_query,
        locator: *mut raptor_locator,
        message: *const libc::c_char,
    ),
>;
/// rasqal_triples_error_handler2:
/// @world: world object
/// @locator: error locator (or NULL)
/// @message: error message
///
/// Triples source factory error handler callback.
pub type rasqal_triples_error_handler2 = ::std::option::Option<
    unsafe extern "C" fn(
        world: *mut rasqal_world,
        locator: *mut raptor_locator,
        message: *const libc::c_char,
    ),
>;
/// rasqal_triples_source_factory:
/// @version: API factory version from 1 to 3
/// @user_data: User data for triples_source_factory.
/// @user_data_size: Size of @user_data for new_triples_source.
/// @new_triples_source: Create a new triples source - returns non-zero on failure &lt; 0 is a 'no rdf data error', &gt; 0 is an unspecified error. Error messages are generated by rasqal internally. (V1)
/// @init_triples_source: Initialise a new triples source V2 for a particular source URI/base URI and syntax. Returns non-zero on failure with errors reported via the handler callback by the implementation. (V2)
/// @init_triples_source2: Initialise a new triples source V3 for a particular source URI/base URI and syntax and given data graphs. Returns non-zero on failure with errors reported via the handler callback by the implementation. If bit 0 of flags is 1, enforce RAPTOR_FEATURE_NO_NET (V3)
///
/// A factory that initialises #rasqal_triples_source structures to
/// returning matches to a triple pattern across the dataset formed
/// from the data graphs recorded in the @query object.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rasqal_triples_source_factory {
    pub version: libc::c_int,
    pub user_data: *mut libc::c_void,
    pub user_data_size: usize,
    pub new_triples_source: ::std::option::Option<
        unsafe extern "C" fn(
            query: *mut rasqal_query,
            factory_user_data: *mut libc::c_void,
            user_data: *mut libc::c_void,
            rts: *mut rasqal_triples_source,
        ) -> libc::c_int,
    >,
    pub init_triples_source: ::std::option::Option<
        unsafe extern "C" fn(
            query: *mut rasqal_query,
            factory_user_data: *mut libc::c_void,
            user_data: *mut libc::c_void,
            rts: *mut rasqal_triples_source,
            handler: rasqal_triples_error_handler,
        ) -> libc::c_int,
    >,
    pub init_triples_source2: ::std::option::Option<
        unsafe extern "C" fn(
            world: *mut rasqal_world,
            data_graphs: *mut raptor_sequence,
            factory_user_data: *mut libc::c_void,
            user_data: *mut libc::c_void,
            rts: *mut rasqal_triples_source,
            handler: rasqal_triples_error_handler2,
            flags: libc::c_uint,
        ) -> libc::c_int,
    >,
}
#[test]
fn bindgen_test_layout_rasqal_triples_source_factory() {
    assert_eq!(
        ::std::mem::size_of::<rasqal_triples_source_factory>(),
        48usize,
        concat!("Size of: ", stringify!(rasqal_triples_source_factory))
    );
    assert_eq!(
        ::std::mem::align_of::<rasqal_triples_source_factory>(),
        8usize,
        concat!("Alignment of ", stringify!(rasqal_triples_source_factory))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rasqal_triples_source_factory>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_triples_source_factory),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rasqal_triples_source_factory>())).user_data as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_triples_source_factory),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rasqal_triples_source_factory>())).user_data_size as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_triples_source_factory),
            "::",
            stringify!(user_data_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rasqal_triples_source_factory>())).new_triples_source as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_triples_source_factory),
            "::",
            stringify!(new_triples_source)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rasqal_triples_source_factory>())).init_triples_source
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_triples_source_factory),
            "::",
            stringify!(init_triples_source)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rasqal_triples_source_factory>())).init_triples_source2
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rasqal_triples_source_factory),
            "::",
            stringify!(init_triples_source2)
        )
    );
}
/// rasqal_triples_source_factory_register_fn:
/// @factory: factory to register
///
/// Register a factory for generating triples sources #rasqal_triples_source
///
/// Return value: non-0 on failure
pub type rasqal_triples_source_factory_register_fn = ::std::option::Option<
    unsafe extern "C" fn(factory: *mut rasqal_triples_source_factory) -> libc::c_int,
>;
extern "C" {
    pub fn rasqal_set_triples_source_factory(
        world: *mut rasqal_world,
        register_fn: rasqal_triples_source_factory_register_fn,
        user_data: *mut libc::c_void,
    ) -> libc::c_int;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: libc::c_uint,
    pub fp_offset: libc::c_uint,
    pub overflow_arg_area: *mut libc::c_void,
    pub reg_save_area: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
